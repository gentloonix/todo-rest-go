<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>cldr - Go Documentation Server</title>

<link type="text/css" rel="stylesheet" href="/lib/godoc/style.css">

<script>window.initFuncs = [];</script>
<script src="/lib/godoc/jquery.js" defer></script>



<script>var goVersion = "go1.19.2";</script>
<script src="/lib/godoc/godocs.js" defer></script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="/pkg/">Go Documentation Server</a></div>
<div class="top-heading" id="heading-narrow"><a href="/pkg/">GoDoc</a></div>
<a href="#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="/search">
<div id="menu">

<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package cldr
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "golang.org/x/text/unicode/cldr"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
				<dd><a href="#pkg-examples" class="examplesLink">Examples</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>Package cldr provides a parser for LDML and related XML formats.
<p>This package is intended to be used by the table generation tools for the
various packages in x/text and is not internal for historical reasons.
<p>As the XML types are generated from the CLDR DTD, and as the CLDR standard is
periodically amended, this package may change considerably over time. This
mostly means that data may appear and disappear between versions. That is,
old code should keep compiling for newer versions, but data may have moved or
changed. CLDR version 22 is the first version supported by this package.
Older versions may not work.

				
			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
				<dd><a href="#pkg-constants">Constants</a></dd>
			
			
			
				
				<dd><a href="#Key">func Key(e Elem, exclude ...string) string</a></dd>
			
			
				
				<dd><a href="#CLDR">type CLDR</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#CLDR.BCP47">func (cldr *CLDR) BCP47() *LDMLBCP47</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CLDR.LDML">func (cldr *CLDR) LDML(loc string) (*LDML, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CLDR.Locales">func (cldr *CLDR) Locales() []string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CLDR.RawLDML">func (cldr *CLDR) RawLDML(loc string) *LDML</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CLDR.SetDraftLevel">func (cldr *CLDR) SetDraftLevel(lev Draft, preferDraft bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CLDR.Supplemental">func (cldr *CLDR) Supplemental() *SupplementalData</a></dd>
				
			
				
				<dd><a href="#Calendar">type Calendar</a></dd>
				
				
			
				
				<dd><a href="#Collation">type Collation</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Collation.Process">func (c Collation) Process(p RuleProcessor) (err error)</a></dd>
				
			
				
				<dd><a href="#Common">type Common</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Common.Data">func (e *Common) Data() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Common.Default">func (e *Common) Default() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Common.Element">func (e *Common) Element() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Common.GetCommon">func (e *Common) GetCommon() *Common</a></dd>
				
			
				
				<dd><a href="#Decoder">type Decoder</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Decoder.Decode">func (d *Decoder) Decode(l Loader) (cldr *CLDR, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Decoder.DecodePath">func (d *Decoder) DecodePath(path string) (cldr *CLDR, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Decoder.DecodeZip">func (d *Decoder) DecodeZip(r io.Reader) (cldr *CLDR, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Decoder.SetDirFilter">func (d *Decoder) SetDirFilter(dir ...string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Decoder.SetSectionFilter">func (d *Decoder) SetSectionFilter(filter ...string)</a></dd>
				
			
				
				<dd><a href="#Draft">type Draft</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ParseDraft">func ParseDraft(level string) (Draft, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Draft.String">func (d Draft) String() string</a></dd>
				
			
				
				<dd><a href="#Elem">type Elem</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Get">func Get(e Elem, path string) (res Elem, err error)</a></dd>
				
				
			
				
				<dd><a href="#LDML">type LDML</a></dd>
				
				
			
				
				<dd><a href="#LDMLBCP47">type LDMLBCP47</a></dd>
				
				
			
				
				<dd><a href="#Loader">type Loader</a></dd>
				
				
			
				
				<dd><a href="#LocaleDisplayNames">type LocaleDisplayNames</a></dd>
				
				
			
				
				<dd><a href="#Numbers">type Numbers</a></dd>
				
				
			
				
				<dd><a href="#RuleProcessor">type RuleProcessor</a></dd>
				
				
			
				
				<dd><a href="#Slice">type Slice</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MakeSlice">func MakeSlice(slicePtr interface{}) Slice</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Slice.Filter">func (s Slice) Filter(fn func(e Elem) bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Slice.Group">func (s Slice) Group(fn func(e Elem) string) []Slice</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Slice.SelectAnyOf">func (s Slice) SelectAnyOf(attr string, values ...string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Slice.SelectDraft">func (s Slice) SelectDraft(d Draft)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Slice.SelectOnePerGroup">func (s Slice) SelectOnePerGroup(a string, v []string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Slice.Value">func (s *Slice) Value() reflect.Value</a></dd>
				
			
				
				<dd><a href="#SupplementalData">type SupplementalData</a></dd>
				
				
			
				
				<dd><a href="#TimeZoneNames">type TimeZoneNames</a></dd>
				
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		
		<div id="pkg-examples">
			<h3>Examples</h3>
			<div class="js-expandAll expandAll collapsed">(Expand All)</div>
			<dl>
			
			<dd><a class="exampleLink" href="#example_Decoder">Decoder</a></dd>
			
			<dd><a class="exampleLink" href="#example_Decoder_DecodePath">Decoder.DecodePath</a></dd>
			
			<dd><a class="exampleLink" href="#example_Decoder_DecodeZip">Decoder.DecodeZip</a></dd>
			
			<dd><a class="exampleLink" href="#example_Slice">Slice</a></dd>
			
			</dl>
		</div>
		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="/src/golang.org/x/text/unicode/cldr/base.go">base.go</a>
			
				<a href="/src/golang.org/x/text/unicode/cldr/cldr.go">cldr.go</a>
			
				<a href="/src/golang.org/x/text/unicode/cldr/collate.go">collate.go</a>
			
				<a href="/src/golang.org/x/text/unicode/cldr/decode.go">decode.go</a>
			
				<a href="/src/golang.org/x/text/unicode/cldr/resolve.go">resolve.go</a>
			
				<a href="/src/golang.org/x/text/unicode/cldr/slice.go">slice.go</a>
			
				<a href="/src/golang.org/x/text/unicode/cldr/xml.go">xml.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
			<h2 id="pkg-constants">Constants</h2>
			
				<p>Version is the version of CLDR from which the XML definitions are generated.

				<pre>const <span id="Version">Version</span> = &#34;32&#34;</pre>
			
		
		
		
			
			
			<h2 id="Key">func <a href="/src/golang.org/x/text/unicode/cldr/resolve.go?s=8284:8326#L326">Key</a>
				<a class="permalink" href="#Key">&#xb6;</a>
				
				
			</h2>
			<pre>func Key(e <a href="#Elem">Elem</a>, exclude ...<a href="/pkg/builtin/#string">string</a>) <a href="/pkg/builtin/#string">string</a></pre>
			<p>Key returns a key for e derived from all distinguishing attributes
except those specified by exclude.

			
			

		
		
			
			
			<h2 id="CLDR">type <a href="/src/golang.org/x/text/unicode/cldr/cldr.go?s=1028:1181#L16">CLDR</a>
				<a class="permalink" href="#CLDR">&#xb6;</a>
				
				
			</h2>
			<p>CLDR provides access to parsed data of the Unicode Common Locale Data Repository.

			<pre>type CLDR struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="CLDR.BCP47">func (*CLDR) <a href="/src/golang.org/x/text/unicode/cldr/cldr.go?s=1488:1524#L35">BCP47</a>
					<a class="permalink" href="#CLDR.BCP47">&#xb6;</a>
					
					
				</h3>
				<pre>func (cldr *<a href="#CLDR">CLDR</a>) BCP47() *<a href="#LDMLBCP47">LDMLBCP47</a></pre>
				<p>BCP47 returns the parsed BCP47 LDML data. If no such data was parsed, nil is returned.

				
				
				
			
				
				<h3 id="CLDR.LDML">func (*CLDR) <a href="/src/golang.org/x/text/unicode/cldr/cldr.go?s=3337:3386#L94">LDML</a>
					<a class="permalink" href="#CLDR.LDML">&#xb6;</a>
					
					
				</h3>
				<pre>func (cldr *<a href="#CLDR">CLDR</a>) LDML(loc <a href="/pkg/builtin/#string">string</a>) (*<a href="#LDML">LDML</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>LDML returns the fully resolved LDML XML for loc, which must be one of
the strings returned by Locales.
<p>Deprecated: Use RawLDML and implement inheritance manually or using the
internal cldrtree package.
Inheritance has changed quite a bit since the onset of this package and in
practice data often represented in a way where knowledge of how it was
inherited is relevant.

				
				
				
			
				
				<h3 id="CLDR.Locales">func (*CLDR) <a href="/src/golang.org/x/text/unicode/cldr/cldr.go?s=3762:3798#L107">Locales</a>
					<a class="permalink" href="#CLDR.Locales">&#xb6;</a>
					
					
				</h3>
				<pre>func (cldr *<a href="#CLDR">CLDR</a>) Locales() []<a href="/pkg/builtin/#string">string</a></pre>
				<p>Locales returns the locales for which there exist files.
Valid sublocales for which there is no file are not included.
The root locale is always sorted first.

				
				
				
			
				
				<h3 id="CLDR.RawLDML">func (*CLDR) <a href="/src/golang.org/x/text/unicode/cldr/cldr.go?s=2867:2910#L82">RawLDML</a>
					<a class="permalink" href="#CLDR.RawLDML">&#xb6;</a>
					
					
				</h3>
				<pre>func (cldr *<a href="#CLDR">CLDR</a>) RawLDML(loc <a href="/pkg/builtin/#string">string</a>) *<a href="#LDML">LDML</a></pre>
				<p>RawLDML returns the LDML XML for id in unresolved form.
id must be one of the strings returned by Locales.

				
				
				
			
				
				<h3 id="CLDR.SetDraftLevel">func (*CLDR) <a href="/src/golang.org/x/text/unicode/cldr/cldr.go?s=2628:2688#L75">SetDraftLevel</a>
					<a class="permalink" href="#CLDR.SetDraftLevel">&#xb6;</a>
					
					
				</h3>
				<pre>func (cldr *<a href="#CLDR">CLDR</a>) SetDraftLevel(lev <a href="#Draft">Draft</a>, preferDraft <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>SetDraftLevel sets which draft levels to include in the evaluated LDML.
Any draft element for which the draft level is higher than lev will be excluded.
If multiple draft levels are available for a single element, the one with the
lowest draft level will be selected, unless preferDraft is true, in which case
the highest draft will be chosen.
It is assumed that the underlying LDML is canonicalized.

				
				
				
			
				
				<h3 id="CLDR.Supplemental">func (*CLDR) <a href="/src/golang.org/x/text/unicode/cldr/cldr.go?s=3520:3570#L100">Supplemental</a>
					<a class="permalink" href="#CLDR.Supplemental">&#xb6;</a>
					
					
				</h3>
				<pre>func (cldr *<a href="#CLDR">CLDR</a>) Supplemental() *<a href="#SupplementalData">SupplementalData</a></pre>
				<p>Supplemental returns the parsed supplemental data. If no such data was parsed,
nil is returned.

				
				
				
			
		
			
			
			<h2 id="Calendar">type <a href="/src/golang.org/x/text/unicode/cldr/xml.go?s=26684:31962#L945">Calendar</a>
				<a class="permalink" href="#Calendar">&#xb6;</a>
				
				
			</h2>
			<p>Calendar specifies the fields used for formatting and parsing dates and times.
The month and quarter names are identified numerically, starting at 1.
The day (of the week) names are identified with short strings, since there is
no universally-accepted numeric designation.

			<pre>type Calendar struct {
    <a href="#Common">Common</a>
<span id="Calendar.Months"></span>    Months *struct {
        <a href="#Common">Common</a>
        MonthContext []*struct {
            <a href="#Common">Common</a>
            MonthWidth []*struct {
                <a href="#Common">Common</a>
                Month []*struct {
                    <a href="#Common">Common</a>
                    Yeartype <a href="/pkg/builtin/#string">string</a> `xml:&#34;yeartype,attr&#34;`
                } `xml:&#34;month&#34;`
            } `xml:&#34;monthWidth&#34;`
        } `xml:&#34;monthContext&#34;`
    } `xml:&#34;months&#34;`
<span id="Calendar.MonthNames"></span>    MonthNames *struct {
        <a href="#Common">Common</a>
        Month []*struct {
            <a href="#Common">Common</a>
            Yeartype <a href="/pkg/builtin/#string">string</a> `xml:&#34;yeartype,attr&#34;`
        } `xml:&#34;month&#34;`
    } `xml:&#34;monthNames&#34;`
<span id="Calendar.MonthAbbr"></span>    MonthAbbr *struct {
        <a href="#Common">Common</a>
        Month []*struct {
            <a href="#Common">Common</a>
            Yeartype <a href="/pkg/builtin/#string">string</a> `xml:&#34;yeartype,attr&#34;`
        } `xml:&#34;month&#34;`
    } `xml:&#34;monthAbbr&#34;`
<span id="Calendar.MonthPatterns"></span>    MonthPatterns *struct {
        <a href="#Common">Common</a>
        MonthPatternContext []*struct {
            <a href="#Common">Common</a>
            MonthPatternWidth []*struct {
                <a href="#Common">Common</a>
                MonthPattern []*<a href="#Common">Common</a> `xml:&#34;monthPattern&#34;`
            } `xml:&#34;monthPatternWidth&#34;`
        } `xml:&#34;monthPatternContext&#34;`
    } `xml:&#34;monthPatterns&#34;`
<span id="Calendar.Days"></span>    Days *struct {
        <a href="#Common">Common</a>
        DayContext []*struct {
            <a href="#Common">Common</a>
            DayWidth []*struct {
                <a href="#Common">Common</a>
                Day []*<a href="#Common">Common</a> `xml:&#34;day&#34;`
            } `xml:&#34;dayWidth&#34;`
        } `xml:&#34;dayContext&#34;`
    } `xml:&#34;days&#34;`
<span id="Calendar.DayNames"></span>    DayNames *struct {
        <a href="#Common">Common</a>
        Day []*<a href="#Common">Common</a> `xml:&#34;day&#34;`
    } `xml:&#34;dayNames&#34;`
<span id="Calendar.DayAbbr"></span>    DayAbbr *struct {
        <a href="#Common">Common</a>
        Day []*<a href="#Common">Common</a> `xml:&#34;day&#34;`
    } `xml:&#34;dayAbbr&#34;`
<span id="Calendar.Quarters"></span>    Quarters *struct {
        <a href="#Common">Common</a>
        QuarterContext []*struct {
            <a href="#Common">Common</a>
            QuarterWidth []*struct {
                <a href="#Common">Common</a>
                Quarter []*<a href="#Common">Common</a> `xml:&#34;quarter&#34;`
            } `xml:&#34;quarterWidth&#34;`
        } `xml:&#34;quarterContext&#34;`
    } `xml:&#34;quarters&#34;`
<span id="Calendar.Week"></span>    Week *struct {
        <a href="#Common">Common</a>
        MinDays []*struct {
            <a href="#Common">Common</a>
            Count <a href="/pkg/builtin/#string">string</a> `xml:&#34;count,attr&#34;`
        } `xml:&#34;minDays&#34;`
        FirstDay []*struct {
            <a href="#Common">Common</a>
            Day <a href="/pkg/builtin/#string">string</a> `xml:&#34;day,attr&#34;`
        } `xml:&#34;firstDay&#34;`
        WeekendStart []*struct {
            <a href="#Common">Common</a>
            Day  <a href="/pkg/builtin/#string">string</a> `xml:&#34;day,attr&#34;`
            Time <a href="/pkg/builtin/#string">string</a> `xml:&#34;time,attr&#34;`
        } `xml:&#34;weekendStart&#34;`
        WeekendEnd []*struct {
            <a href="#Common">Common</a>
            Day  <a href="/pkg/builtin/#string">string</a> `xml:&#34;day,attr&#34;`
            Time <a href="/pkg/builtin/#string">string</a> `xml:&#34;time,attr&#34;`
        } `xml:&#34;weekendEnd&#34;`
    } `xml:&#34;week&#34;`
<span id="Calendar.Am"></span>    Am         []*<a href="#Common">Common</a> `xml:&#34;am&#34;`
<span id="Calendar.Pm"></span>    Pm         []*<a href="#Common">Common</a> `xml:&#34;pm&#34;`
<span id="Calendar.DayPeriods"></span>    DayPeriods *struct {
        <a href="#Common">Common</a>
        DayPeriodContext []*struct {
            <a href="#Common">Common</a>
            DayPeriodWidth []*struct {
                <a href="#Common">Common</a>
                DayPeriod []*<a href="#Common">Common</a> `xml:&#34;dayPeriod&#34;`
            } `xml:&#34;dayPeriodWidth&#34;`
        } `xml:&#34;dayPeriodContext&#34;`
    } `xml:&#34;dayPeriods&#34;`
<span id="Calendar.Eras"></span>    Eras *struct {
        <a href="#Common">Common</a>
        EraNames *struct {
            <a href="#Common">Common</a>
            Era []*<a href="#Common">Common</a> `xml:&#34;era&#34;`
        } `xml:&#34;eraNames&#34;`
        EraAbbr *struct {
            <a href="#Common">Common</a>
            Era []*<a href="#Common">Common</a> `xml:&#34;era&#34;`
        } `xml:&#34;eraAbbr&#34;`
        EraNarrow *struct {
            <a href="#Common">Common</a>
            Era []*<a href="#Common">Common</a> `xml:&#34;era&#34;`
        } `xml:&#34;eraNarrow&#34;`
    } `xml:&#34;eras&#34;`
<span id="Calendar.CyclicNameSets"></span>    CyclicNameSets *struct {
        <a href="#Common">Common</a>
        CyclicNameSet []*struct {
            <a href="#Common">Common</a>
            CyclicNameContext []*struct {
                <a href="#Common">Common</a>
                CyclicNameWidth []*struct {
                    <a href="#Common">Common</a>
                    CyclicName []*<a href="#Common">Common</a> `xml:&#34;cyclicName&#34;`
                } `xml:&#34;cyclicNameWidth&#34;`
            } `xml:&#34;cyclicNameContext&#34;`
        } `xml:&#34;cyclicNameSet&#34;`
    } `xml:&#34;cyclicNameSets&#34;`
<span id="Calendar.DateFormats"></span>    DateFormats *struct {
        <a href="#Common">Common</a>
        DateFormatLength []*struct {
            <a href="#Common">Common</a>
            DateFormat []*struct {
                <a href="#Common">Common</a>
                Pattern []*struct {
                    <a href="#Common">Common</a>
                    Numbers <a href="/pkg/builtin/#string">string</a> `xml:&#34;numbers,attr&#34;`
                    Count   <a href="/pkg/builtin/#string">string</a> `xml:&#34;count,attr&#34;`
                } `xml:&#34;pattern&#34;`
                DisplayName []*struct {
                    <a href="#Common">Common</a>
                    Count <a href="/pkg/builtin/#string">string</a> `xml:&#34;count,attr&#34;`
                } `xml:&#34;displayName&#34;`
            } `xml:&#34;dateFormat&#34;`
        } `xml:&#34;dateFormatLength&#34;`
    } `xml:&#34;dateFormats&#34;`
<span id="Calendar.TimeFormats"></span>    TimeFormats *struct {
        <a href="#Common">Common</a>
        TimeFormatLength []*struct {
            <a href="#Common">Common</a>
            TimeFormat []*struct {
                <a href="#Common">Common</a>
                Pattern []*struct {
                    <a href="#Common">Common</a>
                    Numbers <a href="/pkg/builtin/#string">string</a> `xml:&#34;numbers,attr&#34;`
                    Count   <a href="/pkg/builtin/#string">string</a> `xml:&#34;count,attr&#34;`
                } `xml:&#34;pattern&#34;`
                DisplayName []*struct {
                    <a href="#Common">Common</a>
                    Count <a href="/pkg/builtin/#string">string</a> `xml:&#34;count,attr&#34;`
                } `xml:&#34;displayName&#34;`
            } `xml:&#34;timeFormat&#34;`
        } `xml:&#34;timeFormatLength&#34;`
    } `xml:&#34;timeFormats&#34;`
<span id="Calendar.DateTimeFormats"></span>    DateTimeFormats *struct {
        <a href="#Common">Common</a>
        DateTimeFormatLength []*struct {
            <a href="#Common">Common</a>
            DateTimeFormat []*struct {
                <a href="#Common">Common</a>
                Pattern []*struct {
                    <a href="#Common">Common</a>
                    Numbers <a href="/pkg/builtin/#string">string</a> `xml:&#34;numbers,attr&#34;`
                    Count   <a href="/pkg/builtin/#string">string</a> `xml:&#34;count,attr&#34;`
                } `xml:&#34;pattern&#34;`
                DisplayName []*struct {
                    <a href="#Common">Common</a>
                    Count <a href="/pkg/builtin/#string">string</a> `xml:&#34;count,attr&#34;`
                } `xml:&#34;displayName&#34;`
            } `xml:&#34;dateTimeFormat&#34;`
        } `xml:&#34;dateTimeFormatLength&#34;`
        AvailableFormats []*struct {
            <a href="#Common">Common</a>
            DateFormatItem []*struct {
                <a href="#Common">Common</a>
                Id    <a href="/pkg/builtin/#string">string</a> `xml:&#34;id,attr&#34;`
                Count <a href="/pkg/builtin/#string">string</a> `xml:&#34;count,attr&#34;`
            } `xml:&#34;dateFormatItem&#34;`
        } `xml:&#34;availableFormats&#34;`
        AppendItems []*struct {
            <a href="#Common">Common</a>
            AppendItem []*struct {
                <a href="#Common">Common</a>
                Request <a href="/pkg/builtin/#string">string</a> `xml:&#34;request,attr&#34;`
            } `xml:&#34;appendItem&#34;`
        } `xml:&#34;appendItems&#34;`
        IntervalFormats []*struct {
            <a href="#Common">Common</a>
            IntervalFormatFallback []*<a href="#Common">Common</a> `xml:&#34;intervalFormatFallback&#34;`
            IntervalFormatItem     []*struct {
                <a href="#Common">Common</a>
                Id                 <a href="/pkg/builtin/#string">string</a> `xml:&#34;id,attr&#34;`
                GreatestDifference []*struct {
                    <a href="#Common">Common</a>
                    Id <a href="/pkg/builtin/#string">string</a> `xml:&#34;id,attr&#34;`
                } `xml:&#34;greatestDifference&#34;`
            } `xml:&#34;intervalFormatItem&#34;`
        } `xml:&#34;intervalFormats&#34;`
    } `xml:&#34;dateTimeFormats&#34;`
<span id="Calendar.Fields"></span>    Fields []*struct {
        <a href="#Common">Common</a>
        Field []*struct {
            <a href="#Common">Common</a>
            DisplayName []*struct {
                <a href="#Common">Common</a>
                Count <a href="/pkg/builtin/#string">string</a> `xml:&#34;count,attr&#34;`
            } `xml:&#34;displayName&#34;`
            Relative     []*<a href="#Common">Common</a> `xml:&#34;relative&#34;`
            RelativeTime []*struct {
                <a href="#Common">Common</a>
                RelativeTimePattern []*struct {
                    <a href="#Common">Common</a>
                    Count <a href="/pkg/builtin/#string">string</a> `xml:&#34;count,attr&#34;`
                } `xml:&#34;relativeTimePattern&#34;`
            } `xml:&#34;relativeTime&#34;`
            RelativePeriod []*<a href="#Common">Common</a> `xml:&#34;relativePeriod&#34;`
        } `xml:&#34;field&#34;`
    } `xml:&#34;fields&#34;`
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Collation">type <a href="/src/golang.org/x/text/unicode/cldr/xml.go?s=25364:26397#L912">Collation</a>
				<a class="permalink" href="#Collation">&#xb6;</a>
				
				
			</h2>
			<p>Collation contains rules that specify a certain sort-order,
as a tailoring of the root order.
The parsed rules are obtained by passing a RuleProcessor to Collation&apos;s
Process method.

			<pre>type Collation struct {
    <a href="#Common">Common</a>
<span id="Collation.Visibility"></span>    Visibility <a href="/pkg/builtin/#string">string</a>  `xml:&#34;visibility,attr&#34;`
<span id="Collation.Base"></span>    Base       *<a href="#Common">Common</a> `xml:&#34;base&#34;`
<span id="Collation.Import"></span>    Import     []*struct {
        <a href="#Common">Common</a>
        Source <a href="/pkg/builtin/#string">string</a> `xml:&#34;source,attr&#34;`
    } `xml:&#34;import&#34;`
<span id="Collation.Settings"></span>    Settings *struct {
        <a href="#Common">Common</a>
        Strength           <a href="/pkg/builtin/#string">string</a> `xml:&#34;strength,attr&#34;`
        Alternate          <a href="/pkg/builtin/#string">string</a> `xml:&#34;alternate,attr&#34;`
        Backwards          <a href="/pkg/builtin/#string">string</a> `xml:&#34;backwards,attr&#34;`
        Normalization      <a href="/pkg/builtin/#string">string</a> `xml:&#34;normalization,attr&#34;`
        CaseLevel          <a href="/pkg/builtin/#string">string</a> `xml:&#34;caseLevel,attr&#34;`
        CaseFirst          <a href="/pkg/builtin/#string">string</a> `xml:&#34;caseFirst,attr&#34;`
        HiraganaQuaternary <a href="/pkg/builtin/#string">string</a> `xml:&#34;hiraganaQuaternary,attr&#34;`
        MaxVariable        <a href="/pkg/builtin/#string">string</a> `xml:&#34;maxVariable,attr&#34;`
        Numeric            <a href="/pkg/builtin/#string">string</a> `xml:&#34;numeric,attr&#34;`
        Private            <a href="/pkg/builtin/#string">string</a> `xml:&#34;private,attr&#34;`
        VariableTop        <a href="/pkg/builtin/#string">string</a> `xml:&#34;variableTop,attr&#34;`
        Reorder            <a href="/pkg/builtin/#string">string</a> `xml:&#34;reorder,attr&#34;`
    } `xml:&#34;settings&#34;`
<span id="Collation.SuppressContractions"></span>    SuppressContractions *<a href="#Common">Common</a>   `xml:&#34;suppress_contractions&#34;`
<span id="Collation.Optimize"></span>    Optimize             *<a href="#Common">Common</a>   `xml:&#34;optimize&#34;`
<span id="Collation.Cr"></span>    Cr                   []*<a href="#Common">Common</a> `xml:&#34;cr&#34;`
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Collation.Process">func (Collation) <a href="/src/golang.org/x/text/unicode/cldr/collate.go?s=1102:1157#L30">Process</a>
					<a class="permalink" href="#Collation.Process">&#xb6;</a>
					
					
				</h3>
				<pre>func (c <a href="#Collation">Collation</a>) Process(p <a href="#RuleProcessor">RuleProcessor</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Process parses the rules for the tailorings of this collation
and calls the respective methods of p for each rule found.

				
				
				
			
		
			
			
			<h2 id="Common">type <a href="/src/golang.org/x/text/unicode/cldr/base.go?s=771:1149#L28">Common</a>
				<a class="permalink" href="#Common">&#xb6;</a>
				
				
			</h2>
			<p>Common holds several of the most common attributes and sub elements
of an XML element.

			<pre>type Common struct {
<span id="Common.XMLName"></span>    XMLName <a href="/pkg/encoding/xml/">xml</a>.<a href="/pkg/encoding/xml/#Name">Name</a>

<span id="Common.Type"></span>    Type            <a href="/pkg/builtin/#string">string</a> `xml:&#34;type,attr,omitempty&#34;`
<span id="Common.Reference"></span>    Reference       <a href="/pkg/builtin/#string">string</a> `xml:&#34;reference,attr,omitempty&#34;`
<span id="Common.Alt"></span>    Alt             <a href="/pkg/builtin/#string">string</a> `xml:&#34;alt,attr,omitempty&#34;`
<span id="Common.ValidSubLocales"></span>    ValidSubLocales <a href="/pkg/builtin/#string">string</a> `xml:&#34;validSubLocales,attr,omitempty&#34;`
<span id="Common.Draft"></span>    Draft           <a href="/pkg/builtin/#string">string</a> `xml:&#34;draft,attr,omitempty&#34;`
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Common.Data">func (*Common) <a href="/src/golang.org/x/text/unicode/cldr/base.go?s=1793:1823#L66">Data</a>
					<a class="permalink" href="#Common.Data">&#xb6;</a>
					
					
				</h3>
				<pre>func (e *<a href="#Common">Common</a>) Data() <a href="/pkg/builtin/#string">string</a></pre>
				<p>Data returns the character data accumulated for this element.

				
				
				
			
				
				<h3 id="Common.Default">func (*Common) <a href="/src/golang.org/x/text/unicode/cldr/base.go?s=1263:1296#L42">Default</a>
					<a class="permalink" href="#Common.Default">&#xb6;</a>
					
					
				</h3>
				<pre>func (e *<a href="#Common">Common</a>) Default() <a href="/pkg/builtin/#string">string</a></pre>
				<p>Default returns the default type to select from the enclosed list
or &quot;&quot; if no default value is specified.

				
				
				
			
				
				<h3 id="Common.Element">func (*Common) <a href="/src/golang.org/x/text/unicode/cldr/base.go?s=1549:1582#L56">Element</a>
					<a class="permalink" href="#Common.Element">&#xb6;</a>
					
					
				</h3>
				<pre>func (e *<a href="#Common">Common</a>) Element() <a href="/pkg/builtin/#string">string</a></pre>
				<p>Element returns the XML element name.

				
				
				
			
				
				<h3 id="Common.GetCommon">func (*Common) <a href="/src/golang.org/x/text/unicode/cldr/base.go?s=1676:1712#L61">GetCommon</a>
					<a class="permalink" href="#Common.GetCommon">&#xb6;</a>
					
					
				</h3>
				<pre>func (e *<a href="#Common">Common</a>) GetCommon() *<a href="#Common">Common</a></pre>
				<p>GetCommon returns e. It is provided such that Common implements Elem.

				
				
				
			
		
			
			
			<h2 id="Decoder">type <a href="/src/golang.org/x/text/unicode/cldr/decode.go?s=336:472#L11">Decoder</a>
				<a class="permalink" href="#Decoder">&#xb6;</a>
				
				
			</h2>
			<p>A Decoder loads an archive of CLDR data.

			<pre>type Decoder struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			<div id="example_Decoder" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
<span class="comment">// Obtain the default CLDR reader (only for x/text packages).</span>

var d cldr.Decoder

<span class="comment">// Speed up decoding by setting filters for only what you need.</span>
d.SetDirFilter(&#34;main&#34;, &#34;supplemental&#34;)
d.SetSectionFilter(&#34;numbers&#34;, &#34;plurals&#34;)

cldr, err := d.DecodeZip(gen.OpenCLDRCoreZip())
if err != nil {
    fmt.Println(&#34;ERROR&#34;, err)
    return
}
supplemental := cldr.Supplemental()

fmt.Println(supplemental.MeasurementData.MeasurementSystem[0].Type)
for _, lang := range cldr.Locales() {
    data := cldr.RawLDML(lang)
    fmt.Println(lang, data.Identity.Version.Number)
}
</pre>
			
		
	</div>
</div>

			
			

			

			
				
				<h3 id="Decoder.Decode">func (*Decoder) <a href="/src/golang.org/x/text/unicode/cldr/decode.go?s=1314:1372#L43">Decode</a>
					<a class="permalink" href="#Decoder.Decode">&#xb6;</a>
					
					
				</h3>
				<pre>func (d *<a href="#Decoder">Decoder</a>) Decode(l <a href="#Loader">Loader</a>) (cldr *<a href="#CLDR">CLDR</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Decode loads and decodes the files represented by l.

				
				
				
			
				
				<h3 id="Decoder.DecodePath">func (*Decoder) <a href="/src/golang.org/x/text/unicode/cldr/decode.go?s=3192:3257#L127">DecodePath</a>
					<a class="permalink" href="#Decoder.DecodePath">&#xb6;</a>
					
					
				</h3>
				<pre>func (d *<a href="#Decoder">Decoder</a>) DecodePath(path <a href="/pkg/builtin/#string">string</a>) (cldr *<a href="#CLDR">CLDR</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>DecodePath loads CLDR data from the given path.

				
				<div id="example_Decoder_DecodePath" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
<span class="comment">// This directory will exist if a go generate has been run in any of the</span>
<span class="comment">// packages in x/text using the cldr package.</span>
path := filepath.FromSlash(&#34;../../DATA/cldr/&#34; + cldr.Version)

var d cldr.Decoder

<span class="comment">// Speed up decoding by setting filters for only what you need.</span>
d.SetDirFilter(&#34;main&#34;)
d.SetSectionFilter(&#34;numbers&#34;)

cldr, err := d.DecodePath(path)
if err != nil {
    <span class="comment">// handle error</span>
    fmt.Println(&#34;ERROR&#34;, err)
    return
}
for _, lang := range cldr.Locales() {
    if numbers := cldr.RawLDML(lang).Numbers; numbers != nil {
        fmt.Println(lang, len(numbers.Symbols))
    }
}
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Decoder.DecodeZip">func (*Decoder) <a href="/src/golang.org/x/text/unicode/cldr/decode.go?s=3700:3764#L152">DecodeZip</a>
					<a class="permalink" href="#Decoder.DecodeZip">&#xb6;</a>
					
					
				</h3>
				<pre>func (d *<a href="#Decoder">Decoder</a>) DecodeZip(r <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Reader">Reader</a>) (cldr *<a href="#CLDR">CLDR</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>DecodeZip loads CLDR data from the zip archive for which r is the source.

				
				<div id="example_Decoder_DecodeZip" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
<span class="comment">// This directory will exist if a go generate has been run in any of the</span>
<span class="comment">// packages in x/text using the cldr package.</span>
path := filepath.FromSlash(&#34;../../DATA/cldr/&#34; + cldr.Version)

var d cldr.Decoder

r, err := os.Open(filepath.Join(path, &#34;core.zip&#34;))
if err != nil {
    fmt.Println(&#34;error:&#34;, err)
    return
}

<span class="comment">// Only loading supplemental data can be done much faster using a dir</span>
<span class="comment">// filter.</span>
d.SetDirFilter(&#34;supplemental&#34;)
cldr, err := d.DecodeZip(r)
if err != nil {
    fmt.Println(&#34;error:&#34;, err)
    return
}

fmt.Println(cldr.Supplemental().MeasurementData.MeasurementSystem[0].Type)
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Decoder.SetDirFilter">func (*Decoder) <a href="/src/golang.org/x/text/unicode/cldr/decode.go?s=970:1015#L29">SetDirFilter</a>
					<a class="permalink" href="#Decoder.SetDirFilter">&#xb6;</a>
					
					
				</h3>
				<pre>func (d *<a href="#Decoder">Decoder</a>) SetDirFilter(dir ...<a href="/pkg/builtin/#string">string</a>)</pre>
				<p>SetDirFilter limits the loading of LDML XML files of the specied directories.
Note that sections may be split across directories differently for different CLDR versions.
For more robust code, use SetSectionFilter.

				
				
				
			
				
				<h3 id="Decoder.SetSectionFilter">func (*Decoder) <a href="/src/golang.org/x/text/unicode/cldr/decode.go?s=624:676#L21">SetSectionFilter</a>
					<a class="permalink" href="#Decoder.SetSectionFilter">&#xb6;</a>
					
					
				</h3>
				<pre>func (d *<a href="#Decoder">Decoder</a>) SetSectionFilter(filter ...<a href="/pkg/builtin/#string">string</a>)</pre>
				<p>SetSectionFilter takes a list top-level LDML element names to which
evaluation of LDML should be limited.  It automatically calls SetDirFilter.

				
				
				
			
		
			
			
			<h2 id="Draft">type <a href="/src/golang.org/x/text/unicode/cldr/cldr.go?s=1592:1606#L40">Draft</a>
				<a class="permalink" href="#Draft">&#xb6;</a>
				
				
			</h2>
			<p>Draft indicates the draft level of an element.

			<pre>type Draft <a href="/pkg/builtin/#int">int</a></pre>

			
				
				<pre>const (
    <span id="Approved">Approved</span> <a href="#Draft">Draft</a> = <a href="/pkg/builtin/#iota">iota</a>
    <span id="Contributed">Contributed</span>
    <span id="Provisional">Provisional</span>
    <span id="Unconfirmed">Unconfirmed</span>
)</pre>
			

			

			
			
			

			
				
				<h3 id="ParseDraft">func <a href="/src/golang.org/x/text/unicode/cldr/cldr.go?s=1883:1927#L53">ParseDraft</a>
					<a class="permalink" href="#ParseDraft">&#xb6;</a>
					
					
				</h3>
				<pre>func ParseDraft(level <a href="/pkg/builtin/#string">string</a>) (<a href="#Draft">Draft</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ParseDraft returns the Draft value corresponding to the given string. The
empty string corresponds to Approved.

				
				
			

			
				
				<h3 id="Draft.String">func (Draft) <a href="/src/golang.org/x/text/unicode/cldr/cldr.go?s=2136:2166#L65">String</a>
					<a class="permalink" href="#Draft.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (d <a href="#Draft">Draft</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Elem">type <a href="/src/golang.org/x/text/unicode/cldr/base.go?s=268:368#L4">Elem</a>
				<a class="permalink" href="#Elem">&#xb6;</a>
				
				
			</h2>
			<p>Elem is implemented by every XML element.

			<pre>type Elem interface {
    GetCommon() *<a href="#Common">Common</a>
    <span class="comment">// contains filtered or unexported methods</span>
}</pre>

			

			

			
			
			

			
				
				<h3 id="Get">func <a href="/src/golang.org/x/text/unicode/cldr/cldr.go?s=4086:4137#L125">Get</a>
					<a class="permalink" href="#Get">&#xb6;</a>
					
					
				</h3>
				<pre>func Get(e <a href="#Elem">Elem</a>, path <a href="/pkg/builtin/#string">string</a>) (res <a href="#Elem">Elem</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Get fills in the fields of x based on the XPath path.

				
				
			

			
		
			
			
			<h2 id="LDML">type <a href="/src/golang.org/x/text/unicode/cldr/xml.go?s=17835:25168#L639">LDML</a>
				<a class="permalink" href="#LDML">&#xb6;</a>
				
				
			</h2>
			<p>LDML is the top-level type for locale-specific data.

			<pre>type LDML struct {
    <a href="#Common">Common</a>
<span id="LDML.Version"></span>    Version  <a href="/pkg/builtin/#string">string</a> `xml:&#34;version,attr&#34;`
<span id="LDML.Identity"></span>    Identity *struct {
        <a href="#Common">Common</a>
        Version *struct {
            <a href="#Common">Common</a>
            Number <a href="/pkg/builtin/#string">string</a> `xml:&#34;number,attr&#34;`
        } `xml:&#34;version&#34;`
        Generation *struct {
            <a href="#Common">Common</a>
            Date <a href="/pkg/builtin/#string">string</a> `xml:&#34;date,attr&#34;`
        } `xml:&#34;generation&#34;`
        Language  *<a href="#Common">Common</a> `xml:&#34;language&#34;`
        Script    *<a href="#Common">Common</a> `xml:&#34;script&#34;`
        Territory *<a href="#Common">Common</a> `xml:&#34;territory&#34;`
        Variant   *<a href="#Common">Common</a> `xml:&#34;variant&#34;`
    } `xml:&#34;identity&#34;`
<span id="LDML.LocaleDisplayNames"></span>    LocaleDisplayNames *<a href="#LocaleDisplayNames">LocaleDisplayNames</a> `xml:&#34;localeDisplayNames&#34;`
<span id="LDML.Layout"></span>    Layout             *struct {
        <a href="#Common">Common</a>
        Orientation []*struct {
            <a href="#Common">Common</a>
<span id="LDML.Characters"></span>            Characters     <a href="/pkg/builtin/#string">string</a>    `xml:&#34;characters,attr&#34;`
            Lines          <a href="/pkg/builtin/#string">string</a>    `xml:&#34;lines,attr&#34;`
            CharacterOrder []*<a href="#Common">Common</a> `xml:&#34;characterOrder&#34;`
            LineOrder      []*<a href="#Common">Common</a> `xml:&#34;lineOrder&#34;`
        } `xml:&#34;orientation&#34;`
        InList []*struct {
            <a href="#Common">Common</a>
            Casing <a href="/pkg/builtin/#string">string</a> `xml:&#34;casing,attr&#34;`
        } `xml:&#34;inList&#34;`
        InText []*<a href="#Common">Common</a> `xml:&#34;inText&#34;`
    } `xml:&#34;layout&#34;`
<span id="LDML.ContextTransforms"></span>    ContextTransforms *struct {
        <a href="#Common">Common</a>
        ContextTransformUsage []*struct {
            <a href="#Common">Common</a>
            ContextTransform []*<a href="#Common">Common</a> `xml:&#34;contextTransform&#34;`
        } `xml:&#34;contextTransformUsage&#34;`
    } `xml:&#34;contextTransforms&#34;`
    Characters *struct {
        <a href="#Common">Common</a>
        ExemplarCharacters []*<a href="#Common">Common</a> `xml:&#34;exemplarCharacters&#34;`
        Ellipsis           []*<a href="#Common">Common</a> `xml:&#34;ellipsis&#34;`
        MoreInformation    []*<a href="#Common">Common</a> `xml:&#34;moreInformation&#34;`
        Stopwords          []*struct {
            <a href="#Common">Common</a>
            StopwordList []*<a href="#Common">Common</a> `xml:&#34;stopwordList&#34;`
        } `xml:&#34;stopwords&#34;`
        IndexLabels []*struct {
            <a href="#Common">Common</a>
            IndexSeparator           []*<a href="#Common">Common</a> `xml:&#34;indexSeparator&#34;`
            CompressedIndexSeparator []*<a href="#Common">Common</a> `xml:&#34;compressedIndexSeparator&#34;`
            IndexRangePattern        []*<a href="#Common">Common</a> `xml:&#34;indexRangePattern&#34;`
            IndexLabelBefore         []*<a href="#Common">Common</a> `xml:&#34;indexLabelBefore&#34;`
            IndexLabelAfter          []*<a href="#Common">Common</a> `xml:&#34;indexLabelAfter&#34;`
            IndexLabel               []*struct {
                <a href="#Common">Common</a>
                IndexSource <a href="/pkg/builtin/#string">string</a> `xml:&#34;indexSource,attr&#34;`
                Priority    <a href="/pkg/builtin/#string">string</a> `xml:&#34;priority,attr&#34;`
            } `xml:&#34;indexLabel&#34;`
        } `xml:&#34;indexLabels&#34;`
        Mapping []*struct {
            <a href="#Common">Common</a>
            Registry <a href="/pkg/builtin/#string">string</a> `xml:&#34;registry,attr&#34;`
        } `xml:&#34;mapping&#34;`
        ParseLenients []*struct {
            <a href="#Common">Common</a>
            Scope        <a href="/pkg/builtin/#string">string</a> `xml:&#34;scope,attr&#34;`
            Level        <a href="/pkg/builtin/#string">string</a> `xml:&#34;level,attr&#34;`
            ParseLenient []*struct {
                <a href="#Common">Common</a>
                Sample <a href="/pkg/builtin/#string">string</a> `xml:&#34;sample,attr&#34;`
            } `xml:&#34;parseLenient&#34;`
        } `xml:&#34;parseLenients&#34;`
    } `xml:&#34;characters&#34;`
<span id="LDML.Delimiters"></span>    Delimiters *struct {
        <a href="#Common">Common</a>
        QuotationStart          []*<a href="#Common">Common</a> `xml:&#34;quotationStart&#34;`
        QuotationEnd            []*<a href="#Common">Common</a> `xml:&#34;quotationEnd&#34;`
        AlternateQuotationStart []*<a href="#Common">Common</a> `xml:&#34;alternateQuotationStart&#34;`
        AlternateQuotationEnd   []*<a href="#Common">Common</a> `xml:&#34;alternateQuotationEnd&#34;`
    } `xml:&#34;delimiters&#34;`
<span id="LDML.Measurement"></span>    Measurement *struct {
        <a href="#Common">Common</a>
        MeasurementSystem []*<a href="#Common">Common</a> `xml:&#34;measurementSystem&#34;`
        PaperSize         []*struct {
            <a href="#Common">Common</a>
            Height []*<a href="#Common">Common</a> `xml:&#34;height&#34;`
            Width  []*<a href="#Common">Common</a> `xml:&#34;width&#34;`
        } `xml:&#34;paperSize&#34;`
    } `xml:&#34;measurement&#34;`
<span id="LDML.Dates"></span>    Dates *struct {
        <a href="#Common">Common</a>
        LocalizedPatternChars []*<a href="#Common">Common</a> `xml:&#34;localizedPatternChars&#34;`
        DateRangePattern      []*<a href="#Common">Common</a> `xml:&#34;dateRangePattern&#34;`
        Calendars             *struct {
            <a href="#Common">Common</a>
            Calendar []*<a href="#Calendar">Calendar</a> `xml:&#34;calendar&#34;`
        } `xml:&#34;calendars&#34;`
        Fields *struct {
            <a href="#Common">Common</a>
            Field []*struct {
                <a href="#Common">Common</a>
                DisplayName []*struct {
                    <a href="#Common">Common</a>
                    Count <a href="/pkg/builtin/#string">string</a> `xml:&#34;count,attr&#34;`
                } `xml:&#34;displayName&#34;`
                Relative     []*<a href="#Common">Common</a> `xml:&#34;relative&#34;`
                RelativeTime []*struct {
                    <a href="#Common">Common</a>
                    RelativeTimePattern []*struct {
                        <a href="#Common">Common</a>
                        Count <a href="/pkg/builtin/#string">string</a> `xml:&#34;count,attr&#34;`
                    } `xml:&#34;relativeTimePattern&#34;`
                } `xml:&#34;relativeTime&#34;`
                RelativePeriod []*<a href="#Common">Common</a> `xml:&#34;relativePeriod&#34;`
            } `xml:&#34;field&#34;`
        } `xml:&#34;fields&#34;`
        TimeZoneNames *<a href="#TimeZoneNames">TimeZoneNames</a> `xml:&#34;timeZoneNames&#34;`
    } `xml:&#34;dates&#34;`
<span id="LDML.Numbers"></span>    Numbers *<a href="#Numbers">Numbers</a> `xml:&#34;numbers&#34;`
<span id="LDML.Units"></span>    Units   *struct {
        <a href="#Common">Common</a>
        Unit []*struct {
            <a href="#Common">Common</a>
            DisplayName []*struct {
                <a href="#Common">Common</a>
                Count <a href="/pkg/builtin/#string">string</a> `xml:&#34;count,attr&#34;`
            } `xml:&#34;displayName&#34;`
            UnitPattern []*struct {
                <a href="#Common">Common</a>
                Count <a href="/pkg/builtin/#string">string</a> `xml:&#34;count,attr&#34;`
            } `xml:&#34;unitPattern&#34;`
            PerUnitPattern []*<a href="#Common">Common</a> `xml:&#34;perUnitPattern&#34;`
        } `xml:&#34;unit&#34;`
        UnitLength []*struct {
            <a href="#Common">Common</a>
            CompoundUnit []*struct {
                <a href="#Common">Common</a>
                CompoundUnitPattern []*<a href="#Common">Common</a> `xml:&#34;compoundUnitPattern&#34;`
            } `xml:&#34;compoundUnit&#34;`
            Unit []*struct {
                <a href="#Common">Common</a>
                DisplayName []*struct {
                    <a href="#Common">Common</a>
                    Count <a href="/pkg/builtin/#string">string</a> `xml:&#34;count,attr&#34;`
                } `xml:&#34;displayName&#34;`
                UnitPattern []*struct {
                    <a href="#Common">Common</a>
                    Count <a href="/pkg/builtin/#string">string</a> `xml:&#34;count,attr&#34;`
                } `xml:&#34;unitPattern&#34;`
                PerUnitPattern []*<a href="#Common">Common</a> `xml:&#34;perUnitPattern&#34;`
            } `xml:&#34;unit&#34;`
            CoordinateUnit []*struct {
                <a href="#Common">Common</a>
                CoordinateUnitPattern []*<a href="#Common">Common</a> `xml:&#34;coordinateUnitPattern&#34;`
            } `xml:&#34;coordinateUnit&#34;`
        } `xml:&#34;unitLength&#34;`
        DurationUnit []*struct {
            <a href="#Common">Common</a>
            DurationUnitPattern []*<a href="#Common">Common</a> `xml:&#34;durationUnitPattern&#34;`
        } `xml:&#34;durationUnit&#34;`
    } `xml:&#34;units&#34;`
<span id="LDML.ListPatterns"></span>    ListPatterns *struct {
        <a href="#Common">Common</a>
        ListPattern []*struct {
            <a href="#Common">Common</a>
            ListPatternPart []*<a href="#Common">Common</a> `xml:&#34;listPatternPart&#34;`
        } `xml:&#34;listPattern&#34;`
    } `xml:&#34;listPatterns&#34;`
<span id="LDML.Collations"></span>    Collations *struct {
        <a href="#Common">Common</a>
        Version          <a href="/pkg/builtin/#string">string</a>       `xml:&#34;version,attr&#34;`
        DefaultCollation *<a href="#Common">Common</a>      `xml:&#34;defaultCollation&#34;`
        Collation        []*<a href="#Collation">Collation</a> `xml:&#34;collation&#34;`
    } `xml:&#34;collations&#34;`
<span id="LDML.Posix"></span>    Posix *struct {
        <a href="#Common">Common</a>
        Messages []*struct {
            <a href="#Common">Common</a>
            Yesstr  []*<a href="#Common">Common</a> `xml:&#34;yesstr&#34;`
            Nostr   []*<a href="#Common">Common</a> `xml:&#34;nostr&#34;`
            Yesexpr []*<a href="#Common">Common</a> `xml:&#34;yesexpr&#34;`
            Noexpr  []*<a href="#Common">Common</a> `xml:&#34;noexpr&#34;`
        } `xml:&#34;messages&#34;`
    } `xml:&#34;posix&#34;`
<span id="LDML.CharacterLabels"></span>    CharacterLabels *struct {
        <a href="#Common">Common</a>
        CharacterLabelPattern []*struct {
            <a href="#Common">Common</a>
            Count <a href="/pkg/builtin/#string">string</a> `xml:&#34;count,attr&#34;`
        } `xml:&#34;characterLabelPattern&#34;`
        CharacterLabel []*<a href="#Common">Common</a> `xml:&#34;characterLabel&#34;`
    } `xml:&#34;characterLabels&#34;`
<span id="LDML.Segmentations"></span>    Segmentations *struct {
        <a href="#Common">Common</a>
        Segmentation []*struct {
            <a href="#Common">Common</a>
            Variables *struct {
                <a href="#Common">Common</a>
                Variable []*struct {
                    <a href="#Common">Common</a>
                    Id <a href="/pkg/builtin/#string">string</a> `xml:&#34;id,attr&#34;`
                } `xml:&#34;variable&#34;`
            } `xml:&#34;variables&#34;`
            SegmentRules *struct {
                <a href="#Common">Common</a>
                Rule []*struct {
                    <a href="#Common">Common</a>
                    Id <a href="/pkg/builtin/#string">string</a> `xml:&#34;id,attr&#34;`
                } `xml:&#34;rule&#34;`
            } `xml:&#34;segmentRules&#34;`
            Exceptions *struct {
                <a href="#Common">Common</a>
                Exception []*<a href="#Common">Common</a> `xml:&#34;exception&#34;`
            } `xml:&#34;exceptions&#34;`
            Suppressions *struct {
                <a href="#Common">Common</a>
                Suppression []*<a href="#Common">Common</a> `xml:&#34;suppression&#34;`
            } `xml:&#34;suppressions&#34;`
        } `xml:&#34;segmentation&#34;`
    } `xml:&#34;segmentations&#34;`
<span id="LDML.Rbnf"></span>    Rbnf *struct {
        <a href="#Common">Common</a>
        RulesetGrouping []*struct {
            <a href="#Common">Common</a>
            Ruleset []*struct {
                <a href="#Common">Common</a>
                Access        <a href="/pkg/builtin/#string">string</a> `xml:&#34;access,attr&#34;`
                AllowsParsing <a href="/pkg/builtin/#string">string</a> `xml:&#34;allowsParsing,attr&#34;`
                Rbnfrule      []*struct {
                    <a href="#Common">Common</a>
                    Value  <a href="/pkg/builtin/#string">string</a> `xml:&#34;value,attr&#34;`
                    Radix  <a href="/pkg/builtin/#string">string</a> `xml:&#34;radix,attr&#34;`
                    Decexp <a href="/pkg/builtin/#string">string</a> `xml:&#34;decexp,attr&#34;`
                } `xml:&#34;rbnfrule&#34;`
            } `xml:&#34;ruleset&#34;`
        } `xml:&#34;rulesetGrouping&#34;`
    } `xml:&#34;rbnf&#34;`
<span id="LDML.Annotations"></span>    Annotations *struct {
        <a href="#Common">Common</a>
        Annotation []*struct {
            <a href="#Common">Common</a>
            Cp  <a href="/pkg/builtin/#string">string</a> `xml:&#34;cp,attr&#34;`
            Tts <a href="/pkg/builtin/#string">string</a> `xml:&#34;tts,attr&#34;`
        } `xml:&#34;annotation&#34;`
    } `xml:&#34;annotations&#34;`
<span id="LDML.Metadata"></span>    Metadata *struct {
        <a href="#Common">Common</a>
        CasingData *struct {
            <a href="#Common">Common</a>
            CasingItem []*struct {
                <a href="#Common">Common</a>
                Override   <a href="/pkg/builtin/#string">string</a> `xml:&#34;override,attr&#34;`
                ForceError <a href="/pkg/builtin/#string">string</a> `xml:&#34;forceError,attr&#34;`
            } `xml:&#34;casingItem&#34;`
        } `xml:&#34;casingData&#34;`
    } `xml:&#34;metadata&#34;`
<span id="LDML.References"></span>    References *struct {
        <a href="#Common">Common</a>
        Reference []*struct {
            <a href="#Common">Common</a>
            Uri <a href="/pkg/builtin/#string">string</a> `xml:&#34;uri,attr&#34;`
        } `xml:&#34;reference&#34;`
    } `xml:&#34;references&#34;`
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="LDMLBCP47">type <a href="/src/golang.org/x/text/unicode/cldr/xml.go?s=175:1408#L1">LDMLBCP47</a>
				<a class="permalink" href="#LDMLBCP47">&#xb6;</a>
				
				
			</h2>
			<p>LDMLBCP47 holds information on allowable values for various variables in LDML.

			<pre>type LDMLBCP47 struct {
    <a href="#Common">Common</a>
<span id="LDMLBCP47.Version"></span>    Version *struct {
        <a href="#Common">Common</a>
        Number <a href="/pkg/builtin/#string">string</a> `xml:&#34;number,attr&#34;`
    } `xml:&#34;version&#34;`
<span id="LDMLBCP47.Generation"></span>    Generation *struct {
        <a href="#Common">Common</a>
        Date <a href="/pkg/builtin/#string">string</a> `xml:&#34;date,attr&#34;`
    } `xml:&#34;generation&#34;`
<span id="LDMLBCP47.Keyword"></span>    Keyword []*struct {
        <a href="#Common">Common</a>
        Key []*struct {
            <a href="#Common">Common</a>
            Extension   <a href="/pkg/builtin/#string">string</a> `xml:&#34;extension,attr&#34;`
            Name        <a href="/pkg/builtin/#string">string</a> `xml:&#34;name,attr&#34;`
            Description <a href="/pkg/builtin/#string">string</a> `xml:&#34;description,attr&#34;`
            Deprecated  <a href="/pkg/builtin/#string">string</a> `xml:&#34;deprecated,attr&#34;`
            Preferred   <a href="/pkg/builtin/#string">string</a> `xml:&#34;preferred,attr&#34;`
            Alias       <a href="/pkg/builtin/#string">string</a> `xml:&#34;alias,attr&#34;`
            ValueType   <a href="/pkg/builtin/#string">string</a> `xml:&#34;valueType,attr&#34;`
            Since       <a href="/pkg/builtin/#string">string</a> `xml:&#34;since,attr&#34;`
            Type        []*struct {
                <a href="#Common">Common</a>
                Name        <a href="/pkg/builtin/#string">string</a> `xml:&#34;name,attr&#34;`
                Description <a href="/pkg/builtin/#string">string</a> `xml:&#34;description,attr&#34;`
                Deprecated  <a href="/pkg/builtin/#string">string</a> `xml:&#34;deprecated,attr&#34;`
                Preferred   <a href="/pkg/builtin/#string">string</a> `xml:&#34;preferred,attr&#34;`
                Alias       <a href="/pkg/builtin/#string">string</a> `xml:&#34;alias,attr&#34;`
                Since       <a href="/pkg/builtin/#string">string</a> `xml:&#34;since,attr&#34;`
            } `xml:&#34;type&#34;`
        } `xml:&#34;key&#34;`
    } `xml:&#34;keyword&#34;`
<span id="LDMLBCP47.Attribute"></span>    Attribute []*struct {
        <a href="#Common">Common</a>
        Name        <a href="/pkg/builtin/#string">string</a> `xml:&#34;name,attr&#34;`
        Description <a href="/pkg/builtin/#string">string</a> `xml:&#34;description,attr&#34;`
        Deprecated  <a href="/pkg/builtin/#string">string</a> `xml:&#34;deprecated,attr&#34;`
        Preferred   <a href="/pkg/builtin/#string">string</a> `xml:&#34;preferred,attr&#34;`
        Since       <a href="/pkg/builtin/#string">string</a> `xml:&#34;since,attr&#34;`
    } `xml:&#34;attribute&#34;`
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Loader">type <a href="/src/golang.org/x/text/unicode/cldr/decode.go?s=1100:1194#L34">Loader</a>
				<a class="permalink" href="#Loader">&#xb6;</a>
				
				
			</h2>
			<p>A Loader provides access to the files of a CLDR archive.

			<pre>type Loader interface {
    Len() <a href="/pkg/builtin/#int">int</a>
    Path(i <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#string">string</a>
    Reader(i <a href="/pkg/builtin/#int">int</a>) (<a href="/pkg/io/">io</a>.<a href="/pkg/io/#ReadCloser">ReadCloser</a>, <a href="/pkg/builtin/#error">error</a>)
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="LocaleDisplayNames">type <a href="/src/golang.org/x/text/unicode/cldr/xml.go?s=33702:34982#L1232">LocaleDisplayNames</a>
				<a class="permalink" href="#LocaleDisplayNames">&#xb6;</a>
				
				
			</h2>
			<p>LocaleDisplayNames specifies localized display names for scripts, languages,
countries, currencies, and variants.

			<pre>type LocaleDisplayNames struct {
    <a href="#Common">Common</a>
<span id="LocaleDisplayNames.LocaleDisplayPattern"></span>    LocaleDisplayPattern *struct {
        <a href="#Common">Common</a>
        LocalePattern        []*<a href="#Common">Common</a> `xml:&#34;localePattern&#34;`
        LocaleSeparator      []*<a href="#Common">Common</a> `xml:&#34;localeSeparator&#34;`
        LocaleKeyTypePattern []*<a href="#Common">Common</a> `xml:&#34;localeKeyTypePattern&#34;`
    } `xml:&#34;localeDisplayPattern&#34;`
<span id="LocaleDisplayNames.Languages"></span>    Languages *struct {
        <a href="#Common">Common</a>
        Language []*<a href="#Common">Common</a> `xml:&#34;language&#34;`
    } `xml:&#34;languages&#34;`
<span id="LocaleDisplayNames.Scripts"></span>    Scripts *struct {
        <a href="#Common">Common</a>
        Script []*<a href="#Common">Common</a> `xml:&#34;script&#34;`
    } `xml:&#34;scripts&#34;`
<span id="LocaleDisplayNames.Territories"></span>    Territories *struct {
        <a href="#Common">Common</a>
        Territory []*<a href="#Common">Common</a> `xml:&#34;territory&#34;`
    } `xml:&#34;territories&#34;`
<span id="LocaleDisplayNames.Subdivisions"></span>    Subdivisions *struct {
        <a href="#Common">Common</a>
        Subdivision []*<a href="#Common">Common</a> `xml:&#34;subdivision&#34;`
    } `xml:&#34;subdivisions&#34;`
<span id="LocaleDisplayNames.Variants"></span>    Variants *struct {
        <a href="#Common">Common</a>
        Variant []*<a href="#Common">Common</a> `xml:&#34;variant&#34;`
    } `xml:&#34;variants&#34;`
<span id="LocaleDisplayNames.Keys"></span>    Keys *struct {
        <a href="#Common">Common</a>
        Key []*<a href="#Common">Common</a> `xml:&#34;key&#34;`
    } `xml:&#34;keys&#34;`
<span id="LocaleDisplayNames.Types"></span>    Types *struct {
        <a href="#Common">Common</a>
        Type []*struct {
            <a href="#Common">Common</a>
            Key <a href="/pkg/builtin/#string">string</a> `xml:&#34;key,attr&#34;`
        } `xml:&#34;type&#34;`
    } `xml:&#34;types&#34;`
<span id="LocaleDisplayNames.TransformNames"></span>    TransformNames *struct {
        <a href="#Common">Common</a>
        TransformName []*<a href="#Common">Common</a> `xml:&#34;transformName&#34;`
    } `xml:&#34;transformNames&#34;`
<span id="LocaleDisplayNames.MeasurementSystemNames"></span>    MeasurementSystemNames *struct {
        <a href="#Common">Common</a>
        MeasurementSystemName []*<a href="#Common">Common</a> `xml:&#34;measurementSystemName&#34;`
    } `xml:&#34;measurementSystemNames&#34;`
<span id="LocaleDisplayNames.CodePatterns"></span>    CodePatterns *struct {
        <a href="#Common">Common</a>
        CodePattern []*<a href="#Common">Common</a> `xml:&#34;codePattern&#34;`
    } `xml:&#34;codePatterns&#34;`
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Numbers">type <a href="/src/golang.org/x/text/unicode/cldr/xml.go?s=35067:40493#L1286">Numbers</a>
				<a class="permalink" href="#Numbers">&#xb6;</a>
				
				
			</h2>
			<p>Numbers supplies information for formatting and parsing numbers and currencies.

			<pre>type Numbers struct {
    <a href="#Common">Common</a>
<span id="Numbers.DefaultNumberingSystem"></span>    DefaultNumberingSystem []*<a href="#Common">Common</a> `xml:&#34;defaultNumberingSystem&#34;`
<span id="Numbers.OtherNumberingSystems"></span>    OtherNumberingSystems  []*struct {
        <a href="#Common">Common</a>
        Native      []*<a href="#Common">Common</a> `xml:&#34;native&#34;`
        Traditional []*<a href="#Common">Common</a> `xml:&#34;traditional&#34;`
        Finance     []*<a href="#Common">Common</a> `xml:&#34;finance&#34;`
    } `xml:&#34;otherNumberingSystems&#34;`
<span id="Numbers.MinimumGroupingDigits"></span>    MinimumGroupingDigits []*<a href="#Common">Common</a> `xml:&#34;minimumGroupingDigits&#34;`
<span id="Numbers.Symbols"></span>    Symbols               []*struct {
        <a href="#Common">Common</a>
        NumberSystem <a href="/pkg/builtin/#string">string</a> `xml:&#34;numberSystem,attr&#34;`
        Decimal      []*struct {
            <a href="#Common">Common</a>
            NumberSystem <a href="/pkg/builtin/#string">string</a> `xml:&#34;numberSystem,attr&#34;`
        } `xml:&#34;decimal&#34;`
        Group []*struct {
            <a href="#Common">Common</a>
            NumberSystem <a href="/pkg/builtin/#string">string</a> `xml:&#34;numberSystem,attr&#34;`
        } `xml:&#34;group&#34;`
        List []*struct {
            <a href="#Common">Common</a>
            NumberSystem <a href="/pkg/builtin/#string">string</a> `xml:&#34;numberSystem,attr&#34;`
        } `xml:&#34;list&#34;`
        PercentSign []*struct {
            <a href="#Common">Common</a>
            NumberSystem <a href="/pkg/builtin/#string">string</a> `xml:&#34;numberSystem,attr&#34;`
        } `xml:&#34;percentSign&#34;`
        NativeZeroDigit []*struct {
            <a href="#Common">Common</a>
            NumberSystem <a href="/pkg/builtin/#string">string</a> `xml:&#34;numberSystem,attr&#34;`
        } `xml:&#34;nativeZeroDigit&#34;`
        PatternDigit []*struct {
            <a href="#Common">Common</a>
            NumberSystem <a href="/pkg/builtin/#string">string</a> `xml:&#34;numberSystem,attr&#34;`
        } `xml:&#34;patternDigit&#34;`
        PlusSign []*struct {
            <a href="#Common">Common</a>
            NumberSystem <a href="/pkg/builtin/#string">string</a> `xml:&#34;numberSystem,attr&#34;`
        } `xml:&#34;plusSign&#34;`
        MinusSign []*struct {
            <a href="#Common">Common</a>
            NumberSystem <a href="/pkg/builtin/#string">string</a> `xml:&#34;numberSystem,attr&#34;`
        } `xml:&#34;minusSign&#34;`
        Exponential []*struct {
            <a href="#Common">Common</a>
            NumberSystem <a href="/pkg/builtin/#string">string</a> `xml:&#34;numberSystem,attr&#34;`
        } `xml:&#34;exponential&#34;`
        SuperscriptingExponent []*<a href="#Common">Common</a> `xml:&#34;superscriptingExponent&#34;`
        PerMille               []*struct {
            <a href="#Common">Common</a>
            NumberSystem <a href="/pkg/builtin/#string">string</a> `xml:&#34;numberSystem,attr&#34;`
        } `xml:&#34;perMille&#34;`
        Infinity []*struct {
            <a href="#Common">Common</a>
            NumberSystem <a href="/pkg/builtin/#string">string</a> `xml:&#34;numberSystem,attr&#34;`
        } `xml:&#34;infinity&#34;`
        Nan []*struct {
            <a href="#Common">Common</a>
            NumberSystem <a href="/pkg/builtin/#string">string</a> `xml:&#34;numberSystem,attr&#34;`
        } `xml:&#34;nan&#34;`
        CurrencyDecimal []*struct {
            <a href="#Common">Common</a>
            NumberSystem <a href="/pkg/builtin/#string">string</a> `xml:&#34;numberSystem,attr&#34;`
        } `xml:&#34;currencyDecimal&#34;`
        CurrencyGroup []*struct {
            <a href="#Common">Common</a>
            NumberSystem <a href="/pkg/builtin/#string">string</a> `xml:&#34;numberSystem,attr&#34;`
        } `xml:&#34;currencyGroup&#34;`
        TimeSeparator []*<a href="#Common">Common</a> `xml:&#34;timeSeparator&#34;`
    } `xml:&#34;symbols&#34;`
<span id="Numbers.DecimalFormats"></span>    DecimalFormats []*struct {
        <a href="#Common">Common</a>
        NumberSystem        <a href="/pkg/builtin/#string">string</a> `xml:&#34;numberSystem,attr&#34;`
        DecimalFormatLength []*struct {
            <a href="#Common">Common</a>
            DecimalFormat []*struct {
                <a href="#Common">Common</a>
                Pattern []*struct {
                    <a href="#Common">Common</a>
                    Numbers <a href="/pkg/builtin/#string">string</a> `xml:&#34;numbers,attr&#34;`
                    Count   <a href="/pkg/builtin/#string">string</a> `xml:&#34;count,attr&#34;`
                } `xml:&#34;pattern&#34;`
            } `xml:&#34;decimalFormat&#34;`
        } `xml:&#34;decimalFormatLength&#34;`
    } `xml:&#34;decimalFormats&#34;`
<span id="Numbers.ScientificFormats"></span>    ScientificFormats []*struct {
        <a href="#Common">Common</a>
        NumberSystem           <a href="/pkg/builtin/#string">string</a> `xml:&#34;numberSystem,attr&#34;`
        ScientificFormatLength []*struct {
            <a href="#Common">Common</a>
            ScientificFormat []*struct {
                <a href="#Common">Common</a>
                Pattern []*struct {
                    <a href="#Common">Common</a>
                    Numbers <a href="/pkg/builtin/#string">string</a> `xml:&#34;numbers,attr&#34;`
                    Count   <a href="/pkg/builtin/#string">string</a> `xml:&#34;count,attr&#34;`
                } `xml:&#34;pattern&#34;`
            } `xml:&#34;scientificFormat&#34;`
        } `xml:&#34;scientificFormatLength&#34;`
    } `xml:&#34;scientificFormats&#34;`
<span id="Numbers.PercentFormats"></span>    PercentFormats []*struct {
        <a href="#Common">Common</a>
        NumberSystem        <a href="/pkg/builtin/#string">string</a> `xml:&#34;numberSystem,attr&#34;`
        PercentFormatLength []*struct {
            <a href="#Common">Common</a>
            PercentFormat []*struct {
                <a href="#Common">Common</a>
                Pattern []*struct {
                    <a href="#Common">Common</a>
                    Numbers <a href="/pkg/builtin/#string">string</a> `xml:&#34;numbers,attr&#34;`
                    Count   <a href="/pkg/builtin/#string">string</a> `xml:&#34;count,attr&#34;`
                } `xml:&#34;pattern&#34;`
            } `xml:&#34;percentFormat&#34;`
        } `xml:&#34;percentFormatLength&#34;`
    } `xml:&#34;percentFormats&#34;`
<span id="Numbers.CurrencyFormats"></span>    CurrencyFormats []*struct {
        <a href="#Common">Common</a>
        NumberSystem    <a href="/pkg/builtin/#string">string</a> `xml:&#34;numberSystem,attr&#34;`
        CurrencySpacing []*struct {
            <a href="#Common">Common</a>
            BeforeCurrency []*struct {
                <a href="#Common">Common</a>
                CurrencyMatch    []*<a href="#Common">Common</a> `xml:&#34;currencyMatch&#34;`
                SurroundingMatch []*<a href="#Common">Common</a> `xml:&#34;surroundingMatch&#34;`
                InsertBetween    []*<a href="#Common">Common</a> `xml:&#34;insertBetween&#34;`
            } `xml:&#34;beforeCurrency&#34;`
            AfterCurrency []*struct {
                <a href="#Common">Common</a>
                CurrencyMatch    []*<a href="#Common">Common</a> `xml:&#34;currencyMatch&#34;`
                SurroundingMatch []*<a href="#Common">Common</a> `xml:&#34;surroundingMatch&#34;`
                InsertBetween    []*<a href="#Common">Common</a> `xml:&#34;insertBetween&#34;`
            } `xml:&#34;afterCurrency&#34;`
        } `xml:&#34;currencySpacing&#34;`
        CurrencyFormatLength []*struct {
            <a href="#Common">Common</a>
            CurrencyFormat []*struct {
                <a href="#Common">Common</a>
                Pattern []*struct {
                    <a href="#Common">Common</a>
                    Numbers <a href="/pkg/builtin/#string">string</a> `xml:&#34;numbers,attr&#34;`
                    Count   <a href="/pkg/builtin/#string">string</a> `xml:&#34;count,attr&#34;`
                } `xml:&#34;pattern&#34;`
            } `xml:&#34;currencyFormat&#34;`
        } `xml:&#34;currencyFormatLength&#34;`
        UnitPattern []*struct {
            <a href="#Common">Common</a>
            Count <a href="/pkg/builtin/#string">string</a> `xml:&#34;count,attr&#34;`
        } `xml:&#34;unitPattern&#34;`
    } `xml:&#34;currencyFormats&#34;`
<span id="Numbers.Currencies"></span>    Currencies *struct {
        <a href="#Common">Common</a>
        Currency []*struct {
            <a href="#Common">Common</a>
            Pattern []*struct {
                <a href="#Common">Common</a>
                Numbers <a href="/pkg/builtin/#string">string</a> `xml:&#34;numbers,attr&#34;`
                Count   <a href="/pkg/builtin/#string">string</a> `xml:&#34;count,attr&#34;`
            } `xml:&#34;pattern&#34;`
            DisplayName []*struct {
                <a href="#Common">Common</a>
                Count <a href="/pkg/builtin/#string">string</a> `xml:&#34;count,attr&#34;`
            } `xml:&#34;displayName&#34;`
            Symbol  []*<a href="#Common">Common</a> `xml:&#34;symbol&#34;`
            Decimal []*struct {
                <a href="#Common">Common</a>
                NumberSystem <a href="/pkg/builtin/#string">string</a> `xml:&#34;numberSystem,attr&#34;`
            } `xml:&#34;decimal&#34;`
            Group []*struct {
                <a href="#Common">Common</a>
                NumberSystem <a href="/pkg/builtin/#string">string</a> `xml:&#34;numberSystem,attr&#34;`
            } `xml:&#34;group&#34;`
        } `xml:&#34;currency&#34;`
    } `xml:&#34;currencies&#34;`
<span id="Numbers.MiscPatterns"></span>    MiscPatterns []*struct {
        <a href="#Common">Common</a>
        NumberSystem <a href="/pkg/builtin/#string">string</a> `xml:&#34;numberSystem,attr&#34;`
        Pattern      []*struct {
            <a href="#Common">Common</a>
            Numbers <a href="/pkg/builtin/#string">string</a> `xml:&#34;numbers,attr&#34;`
            Count   <a href="/pkg/builtin/#string">string</a> `xml:&#34;count,attr&#34;`
        } `xml:&#34;pattern&#34;`
    } `xml:&#34;miscPatterns&#34;`
<span id="Numbers.MinimalPairs"></span>    MinimalPairs []*struct {
        <a href="#Common">Common</a>
        PluralMinimalPairs []*struct {
            <a href="#Common">Common</a>
            Count <a href="/pkg/builtin/#string">string</a> `xml:&#34;count,attr&#34;`
        } `xml:&#34;pluralMinimalPairs&#34;`
        OrdinalMinimalPairs []*struct {
            <a href="#Common">Common</a>
            Ordinal <a href="/pkg/builtin/#string">string</a> `xml:&#34;ordinal,attr&#34;`
        } `xml:&#34;ordinalMinimalPairs&#34;`
    } `xml:&#34;minimalPairs&#34;`
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="RuleProcessor">type <a href="/src/golang.org/x/text/unicode/cldr/collate.go?s=417:561#L10">RuleProcessor</a>
				<a class="permalink" href="#RuleProcessor">&#xb6;</a>
				
				
			</h2>
			<p>RuleProcessor can be passed to Collator&apos;s Process method, which
parses the rules and calls the respective method for each rule found.

			<pre>type RuleProcessor interface {
    Reset(anchor <a href="/pkg/builtin/#string">string</a>, before <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#error">error</a>
    Insert(level <a href="/pkg/builtin/#int">int</a>, str, context, extend <a href="/pkg/builtin/#string">string</a>) <a href="/pkg/builtin/#error">error</a>
    Index(id <a href="/pkg/builtin/#string">string</a>)
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Slice">type <a href="/src/golang.org/x/text/unicode/cldr/slice.go?s=368:426#L6">Slice</a>
				<a class="permalink" href="#Slice">&#xb6;</a>
				
				
			</h2>
			<p>Slice provides utilities for modifying slices of elements.
It can be wrapped around any slice of which the element type implements
interface Elem.

			<pre>type Slice struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			<div id="example_Slice" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
var dr *cldr.CLDR <span class="comment">// assume this is initialized</span>

x, _ := dr.LDML(&#34;en&#34;)
cs := x.Collations.Collation
<span class="comment">// remove all but the default</span>
cldr.MakeSlice(&amp;cs).Filter(func(e cldr.Elem) bool {
    return e.GetCommon().Type != x.Collations.Default()
})
for i, c := range cs {
    fmt.Println(i, c.Type)
}
</pre>
			
		
	</div>
</div>

			
			

			
				
				<h3 id="MakeSlice">func <a href="/src/golang.org/x/text/unicode/cldr/slice.go?s=770:812#L20">MakeSlice</a>
					<a class="permalink" href="#MakeSlice">&#xb6;</a>
					
					
				</h3>
				<pre>func MakeSlice(slicePtr interface{}) <a href="#Slice">Slice</a></pre>
				<p>MakeSlice wraps a pointer to a slice of Elems.
It replaces the array pointed to by the slice so that subsequent modifications
do not alter the data in a CLDR type.
It panics if an incorrect type is passed.

				
				
			

			
				
				<h3 id="Slice.Filter">func (Slice) <a href="/src/golang.org/x/text/unicode/cldr/slice.go?s=1786:1829#L52">Filter</a>
					<a class="permalink" href="#Slice.Filter">&#xb6;</a>
					
					
				</h3>
				<pre>func (s <a href="#Slice">Slice</a>) Filter(fn func(e <a href="#Elem">Elem</a>) <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>Filter filters s to only include elements for which fn returns true.

				
				
				
			
				
				<h3 id="Slice.Group">func (Slice) <a href="/src/golang.org/x/text/unicode/cldr/slice.go?s=2107:2159#L67">Group</a>
					<a class="permalink" href="#Slice.Group">&#xb6;</a>
					
					
				</h3>
				<pre>func (s <a href="#Slice">Slice</a>) Group(fn func(e <a href="#Elem">Elem</a>) <a href="/pkg/builtin/#string">string</a>) []<a href="#Slice">Slice</a></pre>
				<p>Group finds elements in s for which fn returns the same value and groups
them in a new Slice.

				
				
				
			
				
				<h3 id="Slice.SelectAnyOf">func (Slice) <a href="/src/golang.org/x/text/unicode/cldr/slice.go?s=2721:2778#L91">SelectAnyOf</a>
					<a class="permalink" href="#Slice.SelectAnyOf">&#xb6;</a>
					
					
				</h3>
				<pre>func (s <a href="#Slice">Slice</a>) SelectAnyOf(attr <a href="/pkg/builtin/#string">string</a>, values ...<a href="/pkg/builtin/#string">string</a>)</pre>
				<p>SelectAnyOf filters s to contain only elements for which attr matches
any of the values.

				
				
				
			
				
				<h3 id="Slice.SelectDraft">func (Slice) <a href="/src/golang.org/x/text/unicode/cldr/slice.go?s=3995:4030#L132">SelectDraft</a>
					<a class="permalink" href="#Slice.SelectDraft">&#xb6;</a>
					
					
				</h3>
				<pre>func (s <a href="#Slice">Slice</a>) SelectDraft(d <a href="#Draft">Draft</a>)</pre>
				<p>SelectDraft drops all elements from the list with a draft level smaller than d
and selects the highest draft level of the remaining.
This method assumes that the input CLDR is canonicalized.

				
				
				
			
				
				<h3 id="Slice.SelectOnePerGroup">func (Slice) <a href="/src/golang.org/x/text/unicode/cldr/slice.go?s=3242:3296#L104">SelectOnePerGroup</a>
					<a class="permalink" href="#Slice.SelectOnePerGroup">&#xb6;</a>
					
					
				</h3>
				<pre>func (s <a href="#Slice">Slice</a>) SelectOnePerGroup(a <a href="/pkg/builtin/#string">string</a>, v []<a href="/pkg/builtin/#string">string</a>)</pre>
				<p>SelectOnePerGroup filters s to include at most one element e per group of
elements matching Key(attr), where e has an attribute a that matches any
the values in v.
If more than one element in a group matches a value in v preference
is given to the element that matches the first value in v.

				
				
				
			
				
				<h3 id="Slice.Value">func (*Slice) <a href="/src/golang.org/x/text/unicode/cldr/slice.go?s=488:525#L12">Value</a>
					<a class="permalink" href="#Slice.Value">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="#Slice">Slice</a>) Value() <a href="/pkg/reflect/">reflect</a>.<a href="/pkg/reflect/#Value">Value</a></pre>
				<p>Value returns the reflect.Value of the underlying slice.

				
				
				
			
		
			
			
			<h2 id="SupplementalData">type <a href="/src/golang.org/x/text/unicode/cldr/xml.go?s=1560:17777#L41">SupplementalData</a>
				<a class="permalink" href="#SupplementalData">&#xb6;</a>
				
				
			</h2>
			<p>SupplementalData holds information relevant for internationalization
and proper use of CLDR, but that is not contained in the locale hierarchy.

			<pre>type SupplementalData struct {
    <a href="#Common">Common</a>
<span id="SupplementalData.Version"></span>    Version *struct {
        <a href="#Common">Common</a>
        Number <a href="/pkg/builtin/#string">string</a> `xml:&#34;number,attr&#34;`
    } `xml:&#34;version&#34;`
<span id="SupplementalData.Generation"></span>    Generation *struct {
        <a href="#Common">Common</a>
        Date <a href="/pkg/builtin/#string">string</a> `xml:&#34;date,attr&#34;`
    } `xml:&#34;generation&#34;`
<span id="SupplementalData.CurrencyData"></span>    CurrencyData *struct {
        <a href="#Common">Common</a>
        Fractions []*struct {
            <a href="#Common">Common</a>
            Info []*struct {
                <a href="#Common">Common</a>
                Iso4217      <a href="/pkg/builtin/#string">string</a> `xml:&#34;iso4217,attr&#34;`
                Digits       <a href="/pkg/builtin/#string">string</a> `xml:&#34;digits,attr&#34;`
                Rounding     <a href="/pkg/builtin/#string">string</a> `xml:&#34;rounding,attr&#34;`
                CashDigits   <a href="/pkg/builtin/#string">string</a> `xml:&#34;cashDigits,attr&#34;`
                CashRounding <a href="/pkg/builtin/#string">string</a> `xml:&#34;cashRounding,attr&#34;`
            } `xml:&#34;info&#34;`
        } `xml:&#34;fractions&#34;`
        Region []*struct {
            <a href="#Common">Common</a>
            Iso3166  <a href="/pkg/builtin/#string">string</a> `xml:&#34;iso3166,attr&#34;`
            Currency []*struct {
                <a href="#Common">Common</a>
                Before       <a href="/pkg/builtin/#string">string</a> `xml:&#34;before,attr&#34;`
                From         <a href="/pkg/builtin/#string">string</a> `xml:&#34;from,attr&#34;`
                To           <a href="/pkg/builtin/#string">string</a> `xml:&#34;to,attr&#34;`
                Iso4217      <a href="/pkg/builtin/#string">string</a> `xml:&#34;iso4217,attr&#34;`
                Digits       <a href="/pkg/builtin/#string">string</a> `xml:&#34;digits,attr&#34;`
                Rounding     <a href="/pkg/builtin/#string">string</a> `xml:&#34;rounding,attr&#34;`
                CashRounding <a href="/pkg/builtin/#string">string</a> `xml:&#34;cashRounding,attr&#34;`
                Tender       <a href="/pkg/builtin/#string">string</a> `xml:&#34;tender,attr&#34;`
                Alternate    []*struct {
                    <a href="#Common">Common</a>
                    Iso4217 <a href="/pkg/builtin/#string">string</a> `xml:&#34;iso4217,attr&#34;`
                } `xml:&#34;alternate&#34;`
            } `xml:&#34;currency&#34;`
        } `xml:&#34;region&#34;`
    } `xml:&#34;currencyData&#34;`
<span id="SupplementalData.TerritoryContainment"></span>    TerritoryContainment *struct {
        <a href="#Common">Common</a>
        Group []*struct {
            <a href="#Common">Common</a>
            Contains <a href="/pkg/builtin/#string">string</a> `xml:&#34;contains,attr&#34;`
            Grouping <a href="/pkg/builtin/#string">string</a> `xml:&#34;grouping,attr&#34;`
            Status   <a href="/pkg/builtin/#string">string</a> `xml:&#34;status,attr&#34;`
        } `xml:&#34;group&#34;`
    } `xml:&#34;territoryContainment&#34;`
<span id="SupplementalData.SubdivisionContainment"></span>    SubdivisionContainment *struct {
        <a href="#Common">Common</a>
        Subgroup []*struct {
            <a href="#Common">Common</a>
            Subtype  <a href="/pkg/builtin/#string">string</a> `xml:&#34;subtype,attr&#34;`
            Contains <a href="/pkg/builtin/#string">string</a> `xml:&#34;contains,attr&#34;`
        } `xml:&#34;subgroup&#34;`
    } `xml:&#34;subdivisionContainment&#34;`
<span id="SupplementalData.LanguageData"></span>    LanguageData *struct {
        <a href="#Common">Common</a>
        Language []*struct {
            <a href="#Common">Common</a>
            Scripts     <a href="/pkg/builtin/#string">string</a> `xml:&#34;scripts,attr&#34;`
            Territories <a href="/pkg/builtin/#string">string</a> `xml:&#34;territories,attr&#34;`
            Variants    <a href="/pkg/builtin/#string">string</a> `xml:&#34;variants,attr&#34;`
        } `xml:&#34;language&#34;`
    } `xml:&#34;languageData&#34;`
<span id="SupplementalData.TerritoryInfo"></span>    TerritoryInfo *struct {
        <a href="#Common">Common</a>
        Territory []*struct {
            <a href="#Common">Common</a>
            Gdp                <a href="/pkg/builtin/#string">string</a> `xml:&#34;gdp,attr&#34;`
            LiteracyPercent    <a href="/pkg/builtin/#string">string</a> `xml:&#34;literacyPercent,attr&#34;`
            Population         <a href="/pkg/builtin/#string">string</a> `xml:&#34;population,attr&#34;`
            LanguagePopulation []*struct {
                <a href="#Common">Common</a>
                LiteracyPercent   <a href="/pkg/builtin/#string">string</a> `xml:&#34;literacyPercent,attr&#34;`
                WritingPercent    <a href="/pkg/builtin/#string">string</a> `xml:&#34;writingPercent,attr&#34;`
                PopulationPercent <a href="/pkg/builtin/#string">string</a> `xml:&#34;populationPercent,attr&#34;`
                OfficialStatus    <a href="/pkg/builtin/#string">string</a> `xml:&#34;officialStatus,attr&#34;`
            } `xml:&#34;languagePopulation&#34;`
        } `xml:&#34;territory&#34;`
    } `xml:&#34;territoryInfo&#34;`
<span id="SupplementalData.PostalCodeData"></span>    PostalCodeData *struct {
        <a href="#Common">Common</a>
        PostCodeRegex []*struct {
            <a href="#Common">Common</a>
            TerritoryId <a href="/pkg/builtin/#string">string</a> `xml:&#34;territoryId,attr&#34;`
        } `xml:&#34;postCodeRegex&#34;`
    } `xml:&#34;postalCodeData&#34;`
<span id="SupplementalData.CalendarData"></span>    CalendarData *struct {
        <a href="#Common">Common</a>
        Calendar []*struct {
            <a href="#Common">Common</a>
            Territories    <a href="/pkg/builtin/#string">string</a>  `xml:&#34;territories,attr&#34;`
            CalendarSystem *<a href="#Common">Common</a> `xml:&#34;calendarSystem&#34;`
            Eras           *struct {
                <a href="#Common">Common</a>
                Era []*struct {
                    <a href="#Common">Common</a>
                    Start <a href="/pkg/builtin/#string">string</a> `xml:&#34;start,attr&#34;`
                    End   <a href="/pkg/builtin/#string">string</a> `xml:&#34;end,attr&#34;`
                } `xml:&#34;era&#34;`
            } `xml:&#34;eras&#34;`
        } `xml:&#34;calendar&#34;`
    } `xml:&#34;calendarData&#34;`
<span id="SupplementalData.CalendarPreferenceData"></span>    CalendarPreferenceData *struct {
        <a href="#Common">Common</a>
        CalendarPreference []*struct {
            <a href="#Common">Common</a>
            Territories <a href="/pkg/builtin/#string">string</a> `xml:&#34;territories,attr&#34;`
            Ordering    <a href="/pkg/builtin/#string">string</a> `xml:&#34;ordering,attr&#34;`
        } `xml:&#34;calendarPreference&#34;`
    } `xml:&#34;calendarPreferenceData&#34;`
<span id="SupplementalData.WeekData"></span>    WeekData *struct {
        <a href="#Common">Common</a>
        MinDays []*struct {
            <a href="#Common">Common</a>
            Count       <a href="/pkg/builtin/#string">string</a> `xml:&#34;count,attr&#34;`
            Territories <a href="/pkg/builtin/#string">string</a> `xml:&#34;territories,attr&#34;`
        } `xml:&#34;minDays&#34;`
        FirstDay []*struct {
            <a href="#Common">Common</a>
            Day         <a href="/pkg/builtin/#string">string</a> `xml:&#34;day,attr&#34;`
            Territories <a href="/pkg/builtin/#string">string</a> `xml:&#34;territories,attr&#34;`
        } `xml:&#34;firstDay&#34;`
        WeekendStart []*struct {
            <a href="#Common">Common</a>
            Day         <a href="/pkg/builtin/#string">string</a> `xml:&#34;day,attr&#34;`
            Territories <a href="/pkg/builtin/#string">string</a> `xml:&#34;territories,attr&#34;`
        } `xml:&#34;weekendStart&#34;`
        WeekendEnd []*struct {
            <a href="#Common">Common</a>
            Day         <a href="/pkg/builtin/#string">string</a> `xml:&#34;day,attr&#34;`
            Territories <a href="/pkg/builtin/#string">string</a> `xml:&#34;territories,attr&#34;`
        } `xml:&#34;weekendEnd&#34;`
        WeekOfPreference []*struct {
            <a href="#Common">Common</a>
            Locales  <a href="/pkg/builtin/#string">string</a> `xml:&#34;locales,attr&#34;`
            Ordering <a href="/pkg/builtin/#string">string</a> `xml:&#34;ordering,attr&#34;`
        } `xml:&#34;weekOfPreference&#34;`
    } `xml:&#34;weekData&#34;`
<span id="SupplementalData.TimeData"></span>    TimeData *struct {
        <a href="#Common">Common</a>
        Hours []*struct {
            <a href="#Common">Common</a>
            Allowed   <a href="/pkg/builtin/#string">string</a> `xml:&#34;allowed,attr&#34;`
            Preferred <a href="/pkg/builtin/#string">string</a> `xml:&#34;preferred,attr&#34;`
            Regions   <a href="/pkg/builtin/#string">string</a> `xml:&#34;regions,attr&#34;`
        } `xml:&#34;hours&#34;`
    } `xml:&#34;timeData&#34;`
<span id="SupplementalData.MeasurementData"></span>    MeasurementData *struct {
        <a href="#Common">Common</a>
        MeasurementSystem []*struct {
            <a href="#Common">Common</a>
            Category    <a href="/pkg/builtin/#string">string</a> `xml:&#34;category,attr&#34;`
            Territories <a href="/pkg/builtin/#string">string</a> `xml:&#34;territories,attr&#34;`
        } `xml:&#34;measurementSystem&#34;`
        PaperSize []*struct {
            <a href="#Common">Common</a>
            Territories <a href="/pkg/builtin/#string">string</a> `xml:&#34;territories,attr&#34;`
        } `xml:&#34;paperSize&#34;`
    } `xml:&#34;measurementData&#34;`
<span id="SupplementalData.UnitPreferenceData"></span>    UnitPreferenceData *struct {
        <a href="#Common">Common</a>
        UnitPreferences []*struct {
            <a href="#Common">Common</a>
            Category       <a href="/pkg/builtin/#string">string</a> `xml:&#34;category,attr&#34;`
            Usage          <a href="/pkg/builtin/#string">string</a> `xml:&#34;usage,attr&#34;`
            Scope          <a href="/pkg/builtin/#string">string</a> `xml:&#34;scope,attr&#34;`
            UnitPreference []*struct {
                <a href="#Common">Common</a>
                Regions <a href="/pkg/builtin/#string">string</a> `xml:&#34;regions,attr&#34;`
            } `xml:&#34;unitPreference&#34;`
        } `xml:&#34;unitPreferences&#34;`
    } `xml:&#34;unitPreferenceData&#34;`
<span id="SupplementalData.TimezoneData"></span>    TimezoneData *struct {
        <a href="#Common">Common</a>
        MapTimezones []*struct {
            <a href="#Common">Common</a>
            OtherVersion <a href="/pkg/builtin/#string">string</a> `xml:&#34;otherVersion,attr&#34;`
            TypeVersion  <a href="/pkg/builtin/#string">string</a> `xml:&#34;typeVersion,attr&#34;`
            MapZone      []*struct {
                <a href="#Common">Common</a>
                Other     <a href="/pkg/builtin/#string">string</a> `xml:&#34;other,attr&#34;`
                Territory <a href="/pkg/builtin/#string">string</a> `xml:&#34;territory,attr&#34;`
            } `xml:&#34;mapZone&#34;`
        } `xml:&#34;mapTimezones&#34;`
        ZoneFormatting []*struct {
            <a href="#Common">Common</a>
            Multizone   <a href="/pkg/builtin/#string">string</a> `xml:&#34;multizone,attr&#34;`
            TzidVersion <a href="/pkg/builtin/#string">string</a> `xml:&#34;tzidVersion,attr&#34;`
            ZoneItem    []*struct {
                <a href="#Common">Common</a>
                Territory <a href="/pkg/builtin/#string">string</a> `xml:&#34;territory,attr&#34;`
                Aliases   <a href="/pkg/builtin/#string">string</a> `xml:&#34;aliases,attr&#34;`
            } `xml:&#34;zoneItem&#34;`
        } `xml:&#34;zoneFormatting&#34;`
    } `xml:&#34;timezoneData&#34;`
<span id="SupplementalData.Characters"></span>    Characters *struct {
        <a href="#Common">Common</a>
        CharacterFallback []*struct {
            <a href="#Common">Common</a>
            Character []*struct {
                <a href="#Common">Common</a>
                Value      <a href="/pkg/builtin/#string">string</a>    `xml:&#34;value,attr&#34;`
                Substitute []*<a href="#Common">Common</a> `xml:&#34;substitute&#34;`
            } `xml:&#34;character&#34;`
        } `xml:&#34;character-fallback&#34;`
    } `xml:&#34;characters&#34;`
<span id="SupplementalData.Transforms"></span>    Transforms *struct {
        <a href="#Common">Common</a>
        Transform []*struct {
            <a href="#Common">Common</a>
            Source        <a href="/pkg/builtin/#string">string</a>    `xml:&#34;source,attr&#34;`
            Target        <a href="/pkg/builtin/#string">string</a>    `xml:&#34;target,attr&#34;`
            Variant       <a href="/pkg/builtin/#string">string</a>    `xml:&#34;variant,attr&#34;`
            Direction     <a href="/pkg/builtin/#string">string</a>    `xml:&#34;direction,attr&#34;`
            Alias         <a href="/pkg/builtin/#string">string</a>    `xml:&#34;alias,attr&#34;`
            BackwardAlias <a href="/pkg/builtin/#string">string</a>    `xml:&#34;backwardAlias,attr&#34;`
            Visibility    <a href="/pkg/builtin/#string">string</a>    `xml:&#34;visibility,attr&#34;`
            Comment       []*<a href="#Common">Common</a> `xml:&#34;comment&#34;`
            TRule         []*<a href="#Common">Common</a> `xml:&#34;tRule&#34;`
        } `xml:&#34;transform&#34;`
    } `xml:&#34;transforms&#34;`
<span id="SupplementalData.Metadata"></span>    Metadata *struct {
        <a href="#Common">Common</a>
        AttributeOrder *<a href="#Common">Common</a> `xml:&#34;attributeOrder&#34;`
        ElementOrder   *<a href="#Common">Common</a> `xml:&#34;elementOrder&#34;`
        SerialElements *<a href="#Common">Common</a> `xml:&#34;serialElements&#34;`
        Suppress       *struct {
            <a href="#Common">Common</a>
            Attributes []*struct {
                <a href="#Common">Common</a>
                Element        <a href="/pkg/builtin/#string">string</a> `xml:&#34;element,attr&#34;`
                Attribute      <a href="/pkg/builtin/#string">string</a> `xml:&#34;attribute,attr&#34;`
                AttributeValue <a href="/pkg/builtin/#string">string</a> `xml:&#34;attributeValue,attr&#34;`
            } `xml:&#34;attributes&#34;`
        } `xml:&#34;suppress&#34;`
        Validity *struct {
            <a href="#Common">Common</a>
            Variable []*struct {
                <a href="#Common">Common</a>
                Id <a href="/pkg/builtin/#string">string</a> `xml:&#34;id,attr&#34;`
            } `xml:&#34;variable&#34;`
            AttributeValues []*struct {
                <a href="#Common">Common</a>
                Dtds       <a href="/pkg/builtin/#string">string</a> `xml:&#34;dtds,attr&#34;`
                Elements   <a href="/pkg/builtin/#string">string</a> `xml:&#34;elements,attr&#34;`
                Attributes <a href="/pkg/builtin/#string">string</a> `xml:&#34;attributes,attr&#34;`
                Order      <a href="/pkg/builtin/#string">string</a> `xml:&#34;order,attr&#34;`
            } `xml:&#34;attributeValues&#34;`
        } `xml:&#34;validity&#34;`
        Alias *struct {
            <a href="#Common">Common</a>
            LanguageAlias []*struct {
                <a href="#Common">Common</a>
                Replacement <a href="/pkg/builtin/#string">string</a> `xml:&#34;replacement,attr&#34;`
                Reason      <a href="/pkg/builtin/#string">string</a> `xml:&#34;reason,attr&#34;`
            } `xml:&#34;languageAlias&#34;`
            ScriptAlias []*struct {
                <a href="#Common">Common</a>
                Replacement <a href="/pkg/builtin/#string">string</a> `xml:&#34;replacement,attr&#34;`
                Reason      <a href="/pkg/builtin/#string">string</a> `xml:&#34;reason,attr&#34;`
            } `xml:&#34;scriptAlias&#34;`
            TerritoryAlias []*struct {
                <a href="#Common">Common</a>
                Replacement <a href="/pkg/builtin/#string">string</a> `xml:&#34;replacement,attr&#34;`
                Reason      <a href="/pkg/builtin/#string">string</a> `xml:&#34;reason,attr&#34;`
            } `xml:&#34;territoryAlias&#34;`
            SubdivisionAlias []*struct {
                <a href="#Common">Common</a>
                Replacement <a href="/pkg/builtin/#string">string</a> `xml:&#34;replacement,attr&#34;`
                Reason      <a href="/pkg/builtin/#string">string</a> `xml:&#34;reason,attr&#34;`
            } `xml:&#34;subdivisionAlias&#34;`
            VariantAlias []*struct {
                <a href="#Common">Common</a>
                Replacement <a href="/pkg/builtin/#string">string</a> `xml:&#34;replacement,attr&#34;`
                Reason      <a href="/pkg/builtin/#string">string</a> `xml:&#34;reason,attr&#34;`
            } `xml:&#34;variantAlias&#34;`
            ZoneAlias []*struct {
                <a href="#Common">Common</a>
                Replacement <a href="/pkg/builtin/#string">string</a> `xml:&#34;replacement,attr&#34;`
                Reason      <a href="/pkg/builtin/#string">string</a> `xml:&#34;reason,attr&#34;`
            } `xml:&#34;zoneAlias&#34;`
        } `xml:&#34;alias&#34;`
        Deprecated *struct {
            <a href="#Common">Common</a>
            DeprecatedItems []*struct {
                <a href="#Common">Common</a>
                Elements   <a href="/pkg/builtin/#string">string</a> `xml:&#34;elements,attr&#34;`
                Attributes <a href="/pkg/builtin/#string">string</a> `xml:&#34;attributes,attr&#34;`
                Values     <a href="/pkg/builtin/#string">string</a> `xml:&#34;values,attr&#34;`
            } `xml:&#34;deprecatedItems&#34;`
        } `xml:&#34;deprecated&#34;`
        Distinguishing *struct {
            <a href="#Common">Common</a>
            DistinguishingItems []*struct {
                <a href="#Common">Common</a>
                Exclude    <a href="/pkg/builtin/#string">string</a> `xml:&#34;exclude,attr&#34;`
                Elements   <a href="/pkg/builtin/#string">string</a> `xml:&#34;elements,attr&#34;`
                Attributes <a href="/pkg/builtin/#string">string</a> `xml:&#34;attributes,attr&#34;`
            } `xml:&#34;distinguishingItems&#34;`
        } `xml:&#34;distinguishing&#34;`
        Blocking *struct {
            <a href="#Common">Common</a>
            BlockingItems []*struct {
                <a href="#Common">Common</a>
                Elements <a href="/pkg/builtin/#string">string</a> `xml:&#34;elements,attr&#34;`
            } `xml:&#34;blockingItems&#34;`
        } `xml:&#34;blocking&#34;`
        CoverageAdditions *struct {
            <a href="#Common">Common</a>
            LanguageCoverage []*struct {
                <a href="#Common">Common</a>
                Values <a href="/pkg/builtin/#string">string</a> `xml:&#34;values,attr&#34;`
            } `xml:&#34;languageCoverage&#34;`
            ScriptCoverage []*struct {
                <a href="#Common">Common</a>
                Values <a href="/pkg/builtin/#string">string</a> `xml:&#34;values,attr&#34;`
            } `xml:&#34;scriptCoverage&#34;`
            TerritoryCoverage []*struct {
                <a href="#Common">Common</a>
                Values <a href="/pkg/builtin/#string">string</a> `xml:&#34;values,attr&#34;`
            } `xml:&#34;territoryCoverage&#34;`
            CurrencyCoverage []*struct {
                <a href="#Common">Common</a>
                Values <a href="/pkg/builtin/#string">string</a> `xml:&#34;values,attr&#34;`
            } `xml:&#34;currencyCoverage&#34;`
            TimezoneCoverage []*struct {
                <a href="#Common">Common</a>
                Values <a href="/pkg/builtin/#string">string</a> `xml:&#34;values,attr&#34;`
            } `xml:&#34;timezoneCoverage&#34;`
        } `xml:&#34;coverageAdditions&#34;`
        SkipDefaultLocale *struct {
            <a href="#Common">Common</a>
            Services <a href="/pkg/builtin/#string">string</a> `xml:&#34;services,attr&#34;`
        } `xml:&#34;skipDefaultLocale&#34;`
        DefaultContent *struct {
            <a href="#Common">Common</a>
            Locales <a href="/pkg/builtin/#string">string</a> `xml:&#34;locales,attr&#34;`
        } `xml:&#34;defaultContent&#34;`
    } `xml:&#34;metadata&#34;`
<span id="SupplementalData.CodeMappings"></span>    CodeMappings *struct {
        <a href="#Common">Common</a>
        LanguageCodes []*struct {
            <a href="#Common">Common</a>
            Alpha3 <a href="/pkg/builtin/#string">string</a> `xml:&#34;alpha3,attr&#34;`
        } `xml:&#34;languageCodes&#34;`
        TerritoryCodes []*struct {
            <a href="#Common">Common</a>
            Numeric  <a href="/pkg/builtin/#string">string</a> `xml:&#34;numeric,attr&#34;`
            Alpha3   <a href="/pkg/builtin/#string">string</a> `xml:&#34;alpha3,attr&#34;`
            Fips10   <a href="/pkg/builtin/#string">string</a> `xml:&#34;fips10,attr&#34;`
            Internet <a href="/pkg/builtin/#string">string</a> `xml:&#34;internet,attr&#34;`
        } `xml:&#34;territoryCodes&#34;`
        CurrencyCodes []*struct {
            <a href="#Common">Common</a>
            Numeric <a href="/pkg/builtin/#string">string</a> `xml:&#34;numeric,attr&#34;`
        } `xml:&#34;currencyCodes&#34;`
    } `xml:&#34;codeMappings&#34;`
<span id="SupplementalData.ParentLocales"></span>    ParentLocales *struct {
        <a href="#Common">Common</a>
        ParentLocale []*struct {
            <a href="#Common">Common</a>
            Parent  <a href="/pkg/builtin/#string">string</a> `xml:&#34;parent,attr&#34;`
            Locales <a href="/pkg/builtin/#string">string</a> `xml:&#34;locales,attr&#34;`
        } `xml:&#34;parentLocale&#34;`
    } `xml:&#34;parentLocales&#34;`
<span id="SupplementalData.LikelySubtags"></span>    LikelySubtags *struct {
        <a href="#Common">Common</a>
        LikelySubtag []*struct {
            <a href="#Common">Common</a>
            From <a href="/pkg/builtin/#string">string</a> `xml:&#34;from,attr&#34;`
            To   <a href="/pkg/builtin/#string">string</a> `xml:&#34;to,attr&#34;`
        } `xml:&#34;likelySubtag&#34;`
    } `xml:&#34;likelySubtags&#34;`
<span id="SupplementalData.MetazoneInfo"></span>    MetazoneInfo *struct {
        <a href="#Common">Common</a>
        Timezone []*struct {
            <a href="#Common">Common</a>
            UsesMetazone []*struct {
                <a href="#Common">Common</a>
                From  <a href="/pkg/builtin/#string">string</a> `xml:&#34;from,attr&#34;`
                To    <a href="/pkg/builtin/#string">string</a> `xml:&#34;to,attr&#34;`
                Mzone <a href="/pkg/builtin/#string">string</a> `xml:&#34;mzone,attr&#34;`
            } `xml:&#34;usesMetazone&#34;`
        } `xml:&#34;timezone&#34;`
    } `xml:&#34;metazoneInfo&#34;`
<span id="SupplementalData.Plurals"></span>    Plurals []*struct {
        <a href="#Common">Common</a>
        PluralRules []*struct {
            <a href="#Common">Common</a>
            Locales    <a href="/pkg/builtin/#string">string</a> `xml:&#34;locales,attr&#34;`
            PluralRule []*struct {
                <a href="#Common">Common</a>
                Count <a href="/pkg/builtin/#string">string</a> `xml:&#34;count,attr&#34;`
            } `xml:&#34;pluralRule&#34;`
        } `xml:&#34;pluralRules&#34;`
        PluralRanges []*struct {
            <a href="#Common">Common</a>
            Locales     <a href="/pkg/builtin/#string">string</a> `xml:&#34;locales,attr&#34;`
            PluralRange []*struct {
                <a href="#Common">Common</a>
                Start  <a href="/pkg/builtin/#string">string</a> `xml:&#34;start,attr&#34;`
                End    <a href="/pkg/builtin/#string">string</a> `xml:&#34;end,attr&#34;`
                Result <a href="/pkg/builtin/#string">string</a> `xml:&#34;result,attr&#34;`
            } `xml:&#34;pluralRange&#34;`
        } `xml:&#34;pluralRanges&#34;`
    } `xml:&#34;plurals&#34;`
<span id="SupplementalData.TelephoneCodeData"></span>    TelephoneCodeData *struct {
        <a href="#Common">Common</a>
        CodesByTerritory []*struct {
            <a href="#Common">Common</a>
            Territory            <a href="/pkg/builtin/#string">string</a> `xml:&#34;territory,attr&#34;`
            TelephoneCountryCode []*struct {
                <a href="#Common">Common</a>
                Code <a href="/pkg/builtin/#string">string</a> `xml:&#34;code,attr&#34;`
                From <a href="/pkg/builtin/#string">string</a> `xml:&#34;from,attr&#34;`
                To   <a href="/pkg/builtin/#string">string</a> `xml:&#34;to,attr&#34;`
            } `xml:&#34;telephoneCountryCode&#34;`
        } `xml:&#34;codesByTerritory&#34;`
    } `xml:&#34;telephoneCodeData&#34;`
<span id="SupplementalData.NumberingSystems"></span>    NumberingSystems *struct {
        <a href="#Common">Common</a>
        NumberingSystem []*struct {
            <a href="#Common">Common</a>
            Id     <a href="/pkg/builtin/#string">string</a> `xml:&#34;id,attr&#34;`
            Radix  <a href="/pkg/builtin/#string">string</a> `xml:&#34;radix,attr&#34;`
            Digits <a href="/pkg/builtin/#string">string</a> `xml:&#34;digits,attr&#34;`
            Rules  <a href="/pkg/builtin/#string">string</a> `xml:&#34;rules,attr&#34;`
        } `xml:&#34;numberingSystem&#34;`
    } `xml:&#34;numberingSystems&#34;`
<span id="SupplementalData.Bcp47KeywordMappings"></span>    Bcp47KeywordMappings *struct {
        <a href="#Common">Common</a>
        MapKeys *struct {
            <a href="#Common">Common</a>
            KeyMap []*struct {
                <a href="#Common">Common</a>
                Bcp47 <a href="/pkg/builtin/#string">string</a> `xml:&#34;bcp47,attr&#34;`
            } `xml:&#34;keyMap&#34;`
        } `xml:&#34;mapKeys&#34;`
        MapTypes []*struct {
            <a href="#Common">Common</a>
            TypeMap []*struct {
                <a href="#Common">Common</a>
                Bcp47 <a href="/pkg/builtin/#string">string</a> `xml:&#34;bcp47,attr&#34;`
            } `xml:&#34;typeMap&#34;`
        } `xml:&#34;mapTypes&#34;`
    } `xml:&#34;bcp47KeywordMappings&#34;`
<span id="SupplementalData.Gender"></span>    Gender *struct {
        <a href="#Common">Common</a>
        PersonList []*struct {
            <a href="#Common">Common</a>
            Locales <a href="/pkg/builtin/#string">string</a> `xml:&#34;locales,attr&#34;`
        } `xml:&#34;personList&#34;`
    } `xml:&#34;gender&#34;`
<span id="SupplementalData.References"></span>    References *struct {
        <a href="#Common">Common</a>
        Reference []*struct {
            <a href="#Common">Common</a>
            Uri <a href="/pkg/builtin/#string">string</a> `xml:&#34;uri,attr&#34;`
        } `xml:&#34;reference&#34;`
    } `xml:&#34;references&#34;`
<span id="SupplementalData.LanguageMatching"></span>    LanguageMatching *struct {
        <a href="#Common">Common</a>
        LanguageMatches []*struct {
            <a href="#Common">Common</a>
            ParadigmLocales []*struct {
                <a href="#Common">Common</a>
                Locales <a href="/pkg/builtin/#string">string</a> `xml:&#34;locales,attr&#34;`
            } `xml:&#34;paradigmLocales&#34;`
            MatchVariable []*struct {
                <a href="#Common">Common</a>
                Id    <a href="/pkg/builtin/#string">string</a> `xml:&#34;id,attr&#34;`
                Value <a href="/pkg/builtin/#string">string</a> `xml:&#34;value,attr&#34;`
            } `xml:&#34;matchVariable&#34;`
            LanguageMatch []*struct {
                <a href="#Common">Common</a>
                Desired   <a href="/pkg/builtin/#string">string</a> `xml:&#34;desired,attr&#34;`
                Supported <a href="/pkg/builtin/#string">string</a> `xml:&#34;supported,attr&#34;`
                Percent   <a href="/pkg/builtin/#string">string</a> `xml:&#34;percent,attr&#34;`
                Distance  <a href="/pkg/builtin/#string">string</a> `xml:&#34;distance,attr&#34;`
                Oneway    <a href="/pkg/builtin/#string">string</a> `xml:&#34;oneway,attr&#34;`
            } `xml:&#34;languageMatch&#34;`
        } `xml:&#34;languageMatches&#34;`
    } `xml:&#34;languageMatching&#34;`
<span id="SupplementalData.DayPeriodRuleSet"></span>    DayPeriodRuleSet []*struct {
        <a href="#Common">Common</a>
        DayPeriodRules []*struct {
            <a href="#Common">Common</a>
            Locales       <a href="/pkg/builtin/#string">string</a> `xml:&#34;locales,attr&#34;`
            DayPeriodRule []*struct {
                <a href="#Common">Common</a>
                At     <a href="/pkg/builtin/#string">string</a> `xml:&#34;at,attr&#34;`
                After  <a href="/pkg/builtin/#string">string</a> `xml:&#34;after,attr&#34;`
                Before <a href="/pkg/builtin/#string">string</a> `xml:&#34;before,attr&#34;`
                From   <a href="/pkg/builtin/#string">string</a> `xml:&#34;from,attr&#34;`
                To     <a href="/pkg/builtin/#string">string</a> `xml:&#34;to,attr&#34;`
            } `xml:&#34;dayPeriodRule&#34;`
        } `xml:&#34;dayPeriodRules&#34;`
    } `xml:&#34;dayPeriodRuleSet&#34;`
<span id="SupplementalData.MetaZones"></span>    MetaZones *struct {
        <a href="#Common">Common</a>
        MetazoneInfo *struct {
            <a href="#Common">Common</a>
            Timezone []*struct {
                <a href="#Common">Common</a>
                UsesMetazone []*struct {
                    <a href="#Common">Common</a>
                    From  <a href="/pkg/builtin/#string">string</a> `xml:&#34;from,attr&#34;`
                    To    <a href="/pkg/builtin/#string">string</a> `xml:&#34;to,attr&#34;`
                    Mzone <a href="/pkg/builtin/#string">string</a> `xml:&#34;mzone,attr&#34;`
                } `xml:&#34;usesMetazone&#34;`
            } `xml:&#34;timezone&#34;`
        } `xml:&#34;metazoneInfo&#34;`
        MapTimezones *struct {
            <a href="#Common">Common</a>
            OtherVersion <a href="/pkg/builtin/#string">string</a> `xml:&#34;otherVersion,attr&#34;`
            TypeVersion  <a href="/pkg/builtin/#string">string</a> `xml:&#34;typeVersion,attr&#34;`
            MapZone      []*struct {
                <a href="#Common">Common</a>
                Other     <a href="/pkg/builtin/#string">string</a> `xml:&#34;other,attr&#34;`
                Territory <a href="/pkg/builtin/#string">string</a> `xml:&#34;territory,attr&#34;`
            } `xml:&#34;mapZone&#34;`
        } `xml:&#34;mapTimezones&#34;`
    } `xml:&#34;metaZones&#34;`
<span id="SupplementalData.PrimaryZones"></span>    PrimaryZones *struct {
        <a href="#Common">Common</a>
        PrimaryZone []*struct {
            <a href="#Common">Common</a>
            Iso3166 <a href="/pkg/builtin/#string">string</a> `xml:&#34;iso3166,attr&#34;`
        } `xml:&#34;primaryZone&#34;`
    } `xml:&#34;primaryZones&#34;`
<span id="SupplementalData.WindowsZones"></span>    WindowsZones *struct {
        <a href="#Common">Common</a>
        MapTimezones *struct {
            <a href="#Common">Common</a>
            OtherVersion <a href="/pkg/builtin/#string">string</a> `xml:&#34;otherVersion,attr&#34;`
            TypeVersion  <a href="/pkg/builtin/#string">string</a> `xml:&#34;typeVersion,attr&#34;`
            MapZone      []*struct {
                <a href="#Common">Common</a>
                Other     <a href="/pkg/builtin/#string">string</a> `xml:&#34;other,attr&#34;`
                Territory <a href="/pkg/builtin/#string">string</a> `xml:&#34;territory,attr&#34;`
            } `xml:&#34;mapZone&#34;`
        } `xml:&#34;mapTimezones&#34;`
    } `xml:&#34;windowsZones&#34;`
<span id="SupplementalData.CoverageLevels"></span>    CoverageLevels *struct {
        <a href="#Common">Common</a>
        ApprovalRequirements *struct {
            <a href="#Common">Common</a>
            ApprovalRequirement []*struct {
                <a href="#Common">Common</a>
                Votes   <a href="/pkg/builtin/#string">string</a> `xml:&#34;votes,attr&#34;`
                Locales <a href="/pkg/builtin/#string">string</a> `xml:&#34;locales,attr&#34;`
                Paths   <a href="/pkg/builtin/#string">string</a> `xml:&#34;paths,attr&#34;`
            } `xml:&#34;approvalRequirement&#34;`
        } `xml:&#34;approvalRequirements&#34;`
        CoverageVariable []*struct {
            <a href="#Common">Common</a>
            Key   <a href="/pkg/builtin/#string">string</a> `xml:&#34;key,attr&#34;`
            Value <a href="/pkg/builtin/#string">string</a> `xml:&#34;value,attr&#34;`
        } `xml:&#34;coverageVariable&#34;`
        CoverageLevel []*struct {
            <a href="#Common">Common</a>
            InLanguage  <a href="/pkg/builtin/#string">string</a> `xml:&#34;inLanguage,attr&#34;`
            InScript    <a href="/pkg/builtin/#string">string</a> `xml:&#34;inScript,attr&#34;`
            InTerritory <a href="/pkg/builtin/#string">string</a> `xml:&#34;inTerritory,attr&#34;`
            Value       <a href="/pkg/builtin/#string">string</a> `xml:&#34;value,attr&#34;`
            Match       <a href="/pkg/builtin/#string">string</a> `xml:&#34;match,attr&#34;`
        } `xml:&#34;coverageLevel&#34;`
    } `xml:&#34;coverageLevels&#34;`
<span id="SupplementalData.IdValidity"></span>    IdValidity *struct {
        <a href="#Common">Common</a>
        Id []*struct {
            <a href="#Common">Common</a>
            IdStatus <a href="/pkg/builtin/#string">string</a> `xml:&#34;idStatus,attr&#34;`
        } `xml:&#34;id&#34;`
    } `xml:&#34;idValidity&#34;`
<span id="SupplementalData.RgScope"></span>    RgScope *struct {
        <a href="#Common">Common</a>
        RgPath []*struct {
            <a href="#Common">Common</a>
            Path <a href="/pkg/builtin/#string">string</a> `xml:&#34;path,attr&#34;`
        } `xml:&#34;rgPath&#34;`
    } `xml:&#34;rgScope&#34;`
<span id="SupplementalData.LanguageGroups"></span>    LanguageGroups *struct {
        <a href="#Common">Common</a>
        LanguageGroup []*struct {
            <a href="#Common">Common</a>
            Parent <a href="/pkg/builtin/#string">string</a> `xml:&#34;parent,attr&#34;`
        } `xml:&#34;languageGroup&#34;`
    } `xml:&#34;languageGroups&#34;`
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="TimeZoneNames">type <a href="/src/golang.org/x/text/unicode/cldr/xml.go?s=31963:33580#L1174">TimeZoneNames</a>
				<a class="permalink" href="#TimeZoneNames">&#xb6;</a>
				
				
			</h2>
			
			<pre>type TimeZoneNames struct {
    <a href="#Common">Common</a>
<span id="TimeZoneNames.HourFormat"></span>    HourFormat           []*<a href="#Common">Common</a> `xml:&#34;hourFormat&#34;`
<span id="TimeZoneNames.HoursFormat"></span>    HoursFormat          []*<a href="#Common">Common</a> `xml:&#34;hoursFormat&#34;`
<span id="TimeZoneNames.GmtFormat"></span>    GmtFormat            []*<a href="#Common">Common</a> `xml:&#34;gmtFormat&#34;`
<span id="TimeZoneNames.GmtZeroFormat"></span>    GmtZeroFormat        []*<a href="#Common">Common</a> `xml:&#34;gmtZeroFormat&#34;`
<span id="TimeZoneNames.RegionFormat"></span>    RegionFormat         []*<a href="#Common">Common</a> `xml:&#34;regionFormat&#34;`
<span id="TimeZoneNames.FallbackFormat"></span>    FallbackFormat       []*<a href="#Common">Common</a> `xml:&#34;fallbackFormat&#34;`
<span id="TimeZoneNames.FallbackRegionFormat"></span>    FallbackRegionFormat []*<a href="#Common">Common</a> `xml:&#34;fallbackRegionFormat&#34;`
<span id="TimeZoneNames.AbbreviationFallback"></span>    AbbreviationFallback []*<a href="#Common">Common</a> `xml:&#34;abbreviationFallback&#34;`
<span id="TimeZoneNames.PreferenceOrdering"></span>    PreferenceOrdering   []*<a href="#Common">Common</a> `xml:&#34;preferenceOrdering&#34;`
<span id="TimeZoneNames.SingleCountries"></span>    SingleCountries      []*struct {
        <a href="#Common">Common</a>
        List <a href="/pkg/builtin/#string">string</a> `xml:&#34;list,attr&#34;`
    } `xml:&#34;singleCountries&#34;`
<span id="TimeZoneNames.Zone"></span>    Zone []*struct {
        <a href="#Common">Common</a>
        Long []*struct {
            <a href="#Common">Common</a>
            Generic  []*<a href="#Common">Common</a> `xml:&#34;generic&#34;`
            Standard []*<a href="#Common">Common</a> `xml:&#34;standard&#34;`
            Daylight []*<a href="#Common">Common</a> `xml:&#34;daylight&#34;`
        } `xml:&#34;long&#34;`
        Short []*struct {
            <a href="#Common">Common</a>
            Generic  []*<a href="#Common">Common</a> `xml:&#34;generic&#34;`
            Standard []*<a href="#Common">Common</a> `xml:&#34;standard&#34;`
            Daylight []*<a href="#Common">Common</a> `xml:&#34;daylight&#34;`
        } `xml:&#34;short&#34;`
        CommonlyUsed []*struct {
            <a href="#Common">Common</a>
            Used <a href="/pkg/builtin/#string">string</a> `xml:&#34;used,attr&#34;`
        } `xml:&#34;commonlyUsed&#34;`
        ExemplarCity []*<a href="#Common">Common</a> `xml:&#34;exemplarCity&#34;`
    } `xml:&#34;zone&#34;`
<span id="TimeZoneNames.Metazone"></span>    Metazone []*struct {
        <a href="#Common">Common</a>
        Long []*struct {
            <a href="#Common">Common</a>
            Generic  []*<a href="#Common">Common</a> `xml:&#34;generic&#34;`
            Standard []*<a href="#Common">Common</a> `xml:&#34;standard&#34;`
            Daylight []*<a href="#Common">Common</a> `xml:&#34;daylight&#34;`
        } `xml:&#34;long&#34;`
        Short []*struct {
            <a href="#Common">Common</a>
            Generic  []*<a href="#Common">Common</a> `xml:&#34;generic&#34;`
            Standard []*<a href="#Common">Common</a> `xml:&#34;standard&#34;`
            Daylight []*<a href="#Common">Common</a> `xml:&#34;daylight&#34;`
        } `xml:&#34;short&#34;`
        CommonlyUsed []*struct {
            <a href="#Common">Common</a>
            Used <a href="/pkg/builtin/#string">string</a> `xml:&#34;used,attr&#34;`
        } `xml:&#34;commonlyUsed&#34;`
    } `xml:&#34;metazone&#34;`
}
</pre>

			

			

			
			
			

			

			
		
	

	







<div id="footer">
Build version go1.19.2.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="/LICENSE">BSD license</a>.<br>
<a href="https://golang.org/doc/tos.html">Terms of Service</a> |
<a href="https://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->
</body>
</html>
